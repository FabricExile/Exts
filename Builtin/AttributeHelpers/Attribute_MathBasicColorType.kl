
/*
 *  Copyright (c) 2010-2017 Fabric Software Inc. All rights reserved.
 */

operator _MathBasic_Color_Add_Color<<<i>>>(
  io Color result[],
  Color a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Sub_Color<<<i>>>(
  io Color result[],
  Color a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Mul_Color<<<i>>>(
  io Color result[],
  Color a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Min_Color<<<i>>>(
  io Color result[],
  Color a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Max_Color<<<i>>>(
  io Color result[],
  Color a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Interpolate_Color<<<i>>>(
  io Color result[],
  Color a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_AddMul_Color<<<i>>>(
  io Color result[],
  Color a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Scale_Color<<<i>>>(
  io Color result[],
  Color a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}


operator _MathBasic_Color_Add_RGB<<<i>>>(
  io Color result[],
  Color a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Sub_RGB<<<i>>>(
  io Color result[],
  Color a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Mul_RGB<<<i>>>(
  io Color result[],
  Color a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Min_RGB<<<i>>>(
  io Color result[],
  Color a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Max_RGB<<<i>>>(
  io Color result[],
  Color a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Interpolate_RGB<<<i>>>(
  io Color result[],
  Color a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_AddMul_RGB<<<i>>>(
  io Color result[],
  Color a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Scale_RGB<<<i>>>(
  io Color result[],
  Color a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}


operator _MathBasic_Color_Add_RGBA<<<i>>>(
  io Color result[],
  Color a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Sub_RGBA<<<i>>>(
  io Color result[],
  Color a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Mul_RGBA<<<i>>>(
  io Color result[],
  Color a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Min_RGBA<<<i>>>(
  io Color result[],
  Color a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Max_RGBA<<<i>>>(
  io Color result[],
  Color a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Interpolate_RGBA<<<i>>>(
  io Color result[],
  Color a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_AddMul_RGBA<<<i>>>(
  io Color result[],
  Color a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Scale_RGBA<<<i>>>(
  io Color result[],
  Color a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}


operator _MathBasic_Color_Add_Float32<<<i>>>(
  io Color result[],
  Color a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Sub_Float32<<<i>>>(
  io Color result[],
  Color a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Mul_Float32<<<i>>>(
  io Color result[],
  Color a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Min_Float32<<<i>>>(
  io Color result[],
  Color a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Max_Float32<<<i>>>(
  io Color result[],
  Color a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Interpolate_Float32<<<i>>>(
  io Color result[],
  Color a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_AddMul_Float32<<<i>>>(
  io Color result[],
  Color a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  Color bb = useSingleValue ? typedValue : Color(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}

operator _MathBasic_Color_Scale_Float32<<<i>>>(
  io Color result[],
  Color a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Color typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Color v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Color(range.x)) / Color(range.y - range.x);
  }
}


/// \internal
private function Boolean BaseGeometry.performMathBasicColorAttribute!(
  SInt32 mode,
  io GeometryAttributes attributes,
  GeometryAttribute attrA,
  GeometryAttribute attrB,
  String result,
  Scalar t,
  Boolean normalize,
  Vec2 range,
  Boolean useSingleValue,
  Color typedValue
) {
  ColorAttribute castA = attrA;
  if(castA == null)
    return false;
  Color aValues[] = castA.values;

  GeometryAttribute resultAttr = attributes.getAttribute(result);
  if(resultAttr != null)
  {
    if(resultAttr.type() != ColorAttribute)
    {
      report('Error: MathBasic: Result attribute "'+result+'" already exists, but of wrong type.');
      return false;
    }
  }
  ColorAttribute castResult = attributes.getOrCreateColorAttribute(result);
  if(castResult == null)
    return false;
  Color resultValues[] = castResult.values;

  switch(mode)
  {
    case 0: // Add
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Color_Add_Color(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Color_Add_Color<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Add_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Add_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Add_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Add_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Add_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Add_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Add_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Add_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 1: // Sub
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Color_Sub_Color(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Color_Sub_Color<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Sub_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Sub_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Sub_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Sub_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Sub_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Sub_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Sub_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Sub_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 2: // Mul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Color_Mul_Color(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Color_Mul_Color<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Mul_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Mul_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Mul_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Mul_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Mul_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Mul_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Mul_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Mul_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 4: // Min
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Color_Min_Color(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Color_Min_Color<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Min_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Min_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Min_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Min_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Min_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Min_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Min_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Min_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 5: // Max
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Color_Max_Color(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Color_Max_Color<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Max_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Max_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Max_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Max_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Max_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Max_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Max_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Max_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 6: // Interpolate
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Color_Interpolate_Color(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Color_Interpolate_Color<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Interpolate_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Interpolate_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Interpolate_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Interpolate_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Interpolate_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Interpolate_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Interpolate_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Interpolate_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 7: // AddMul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Color_AddMul_Color(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Color_AddMul_Color<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_AddMul_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_AddMul_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_AddMul_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_AddMul_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_AddMul_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_AddMul_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_AddMul_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_AddMul_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 10: // Scale
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Color_Scale_Color(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Color_Scale_Color<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Scale_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Scale_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Scale_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Scale_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Scale_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Scale_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Color_Scale_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Color_Scale_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
  }


  return false;
}

operator _MathBasic_RGB_Add_RGB<<<i>>>(
  io RGB result[],
  RGB a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Sub_RGB<<<i>>>(
  io RGB result[],
  RGB a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Mul_RGB<<<i>>>(
  io RGB result[],
  RGB a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Min_RGB<<<i>>>(
  io RGB result[],
  RGB a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Max_RGB<<<i>>>(
  io RGB result[],
  RGB a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Interpolate_RGB<<<i>>>(
  io RGB result[],
  RGB a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_AddMul_RGB<<<i>>>(
  io RGB result[],
  RGB a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Scale_RGB<<<i>>>(
  io RGB result[],
  RGB a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}


operator _MathBasic_RGB_Add_RGBA<<<i>>>(
  io RGB result[],
  RGB a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Sub_RGBA<<<i>>>(
  io RGB result[],
  RGB a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Mul_RGBA<<<i>>>(
  io RGB result[],
  RGB a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Min_RGBA<<<i>>>(
  io RGB result[],
  RGB a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Max_RGBA<<<i>>>(
  io RGB result[],
  RGB a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Interpolate_RGBA<<<i>>>(
  io RGB result[],
  RGB a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_AddMul_RGBA<<<i>>>(
  io RGB result[],
  RGB a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Scale_RGBA<<<i>>>(
  io RGB result[],
  RGB a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}


operator _MathBasic_RGB_Add_Color<<<i>>>(
  io RGB result[],
  RGB a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Sub_Color<<<i>>>(
  io RGB result[],
  RGB a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Mul_Color<<<i>>>(
  io RGB result[],
  RGB a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Min_Color<<<i>>>(
  io RGB result[],
  RGB a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Max_Color<<<i>>>(
  io RGB result[],
  RGB a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Interpolate_Color<<<i>>>(
  io RGB result[],
  RGB a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_AddMul_Color<<<i>>>(
  io RGB result[],
  RGB a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  RGB bb = useSingleValue ? typedValue : RGB(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}

operator _MathBasic_RGB_Scale_Color<<<i>>>(
  io RGB result[],
  RGB a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGB typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    RGB v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGB(range.x)) / RGB(range.y - range.x);
  }
}


/// \internal
private function Boolean BaseGeometry.performMathBasicRGBAttribute!(
  SInt32 mode,
  io GeometryAttributes attributes,
  GeometryAttribute attrA,
  GeometryAttribute attrB,
  String result,
  Scalar t,
  Boolean normalize,
  Vec2 range,
  Boolean useSingleValue,
  RGB typedValue
) {
  RGBAttribute castA = attrA;
  if(castA == null)
    return false;
  RGB aValues[] = castA.values;

  GeometryAttribute resultAttr = attributes.getAttribute(result);
  if(resultAttr != null)
  {
    if(resultAttr.type() != RGBAttribute)
    {
      report('Error: MathBasic: Result attribute "'+result+'" already exists, but of wrong type.');
      return false;
    }
  }
  RGBAttribute castResult = attributes.getOrCreateRGBAttribute(result);
  if(castResult == null)
    return false;
  RGB resultValues[] = castResult.values;

  switch(mode)
  {
    case 0: // Add
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_RGB_Add_RGB(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_RGB_Add_RGB<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Add_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Add_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Add_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Add_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Add_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Add_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 1: // Sub
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_RGB_Sub_RGB(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_RGB_Sub_RGB<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Sub_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Sub_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Sub_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Sub_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Sub_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Sub_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 2: // Mul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_RGB_Mul_RGB(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_RGB_Mul_RGB<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Mul_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Mul_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Mul_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Mul_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Mul_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Mul_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 4: // Min
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_RGB_Min_RGB(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_RGB_Min_RGB<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Min_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Min_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Min_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Min_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Min_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Min_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 5: // Max
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_RGB_Max_RGB(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_RGB_Max_RGB<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Max_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Max_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Max_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Max_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Max_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Max_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 6: // Interpolate
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_RGB_Interpolate_RGB(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_RGB_Interpolate_RGB<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Interpolate_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Interpolate_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Interpolate_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Interpolate_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Interpolate_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Interpolate_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 7: // AddMul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_RGB_AddMul_RGB(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_RGB_AddMul_RGB<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_AddMul_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_AddMul_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_AddMul_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_AddMul_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_AddMul_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_AddMul_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 10: // Scale
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_RGB_Scale_RGB(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_RGB_Scale_RGB<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Scale_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Scale_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Scale_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Scale_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGB_Scale_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGB_Scale_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
  }


  return false;
}

operator _MathBasic_RGBA_Add_RGBA<<<i>>>(
  io RGBA result[],
  RGBA a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Sub_RGBA<<<i>>>(
  io RGBA result[],
  RGBA a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Mul_RGBA<<<i>>>(
  io RGBA result[],
  RGBA a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Min_RGBA<<<i>>>(
  io RGBA result[],
  RGBA a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Max_RGBA<<<i>>>(
  io RGBA result[],
  RGBA a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Interpolate_RGBA<<<i>>>(
  io RGBA result[],
  RGBA a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_AddMul_RGBA<<<i>>>(
  io RGBA result[],
  RGBA a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Scale_RGBA<<<i>>>(
  io RGBA result[],
  RGBA a[],
  RGBA b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}


operator _MathBasic_RGBA_Add_RGB<<<i>>>(
  io RGBA result[],
  RGBA a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Sub_RGB<<<i>>>(
  io RGBA result[],
  RGBA a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Mul_RGB<<<i>>>(
  io RGBA result[],
  RGBA a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Min_RGB<<<i>>>(
  io RGBA result[],
  RGBA a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Max_RGB<<<i>>>(
  io RGBA result[],
  RGBA a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Interpolate_RGB<<<i>>>(
  io RGBA result[],
  RGBA a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_AddMul_RGB<<<i>>>(
  io RGBA result[],
  RGBA a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Scale_RGB<<<i>>>(
  io RGBA result[],
  RGBA a[],
  RGB b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}


operator _MathBasic_RGBA_Add_Color<<<i>>>(
  io RGBA result[],
  RGBA a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Sub_Color<<<i>>>(
  io RGBA result[],
  RGBA a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Mul_Color<<<i>>>(
  io RGBA result[],
  RGBA a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Min_Color<<<i>>>(
  io RGBA result[],
  RGBA a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Max_Color<<<i>>>(
  io RGBA result[],
  RGBA a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Interpolate_Color<<<i>>>(
  io RGBA result[],
  RGBA a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_AddMul_Color<<<i>>>(
  io RGBA result[],
  RGBA a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  RGBA bb = useSingleValue ? typedValue : RGBA(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}

operator _MathBasic_RGBA_Scale_Color<<<i>>>(
  io RGBA result[],
  RGBA a[],
  Color b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  RGBA typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    RGBA v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - RGBA(range.x)) / RGBA(range.y - range.x);
  }
}


/// \internal
private function Boolean BaseGeometry.performMathBasicRGBAAttribute!(
  SInt32 mode,
  io GeometryAttributes attributes,
  GeometryAttribute attrA,
  GeometryAttribute attrB,
  String result,
  Scalar t,
  Boolean normalize,
  Vec2 range,
  Boolean useSingleValue,
  RGBA typedValue
) {
  RGBAAttribute castA = attrA;
  if(castA == null)
    return false;
  RGBA aValues[] = castA.values;

  GeometryAttribute resultAttr = attributes.getAttribute(result);
  if(resultAttr != null)
  {
    if(resultAttr.type() != RGBAAttribute)
    {
      report('Error: MathBasic: Result attribute "'+result+'" already exists, but of wrong type.');
      return false;
    }
  }
  RGBAAttribute castResult = attributes.getOrCreateRGBAAttribute(result);
  if(castResult == null)
    return false;
  RGBA resultValues[] = castResult.values;

  switch(mode)
  {
    case 0: // Add
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_RGBA_Add_RGBA(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_RGBA_Add_RGBA<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Add_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Add_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Add_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Add_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Add_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Add_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 1: // Sub
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_RGBA_Sub_RGBA(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_RGBA_Sub_RGBA<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Sub_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Sub_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Sub_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Sub_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Sub_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Sub_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 2: // Mul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_RGBA_Mul_RGBA(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_RGBA_Mul_RGBA<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Mul_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Mul_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Mul_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Mul_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Mul_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Mul_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 4: // Min
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_RGBA_Min_RGBA(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_RGBA_Min_RGBA<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Min_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Min_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Min_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Min_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Min_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Min_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 5: // Max
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_RGBA_Max_RGBA(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_RGBA_Max_RGBA<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Max_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Max_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Max_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Max_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Max_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Max_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 6: // Interpolate
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_RGBA_Interpolate_RGBA(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_RGBA_Interpolate_RGBA<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Interpolate_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Interpolate_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Interpolate_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Interpolate_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Interpolate_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Interpolate_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 7: // AddMul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_RGBA_AddMul_RGBA(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_RGBA_AddMul_RGBA<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_AddMul_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_AddMul_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_AddMul_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_AddMul_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_AddMul_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_AddMul_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 10: // Scale
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_RGBA_Scale_RGBA(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_RGBA_Scale_RGBA<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case RGBAAttribute:
          {
            RGBAAttribute castB = attrB;
            if(castB == null)
              return false;

            RGBA bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Scale_RGBA(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Scale_RGBA<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case RGBAttribute:
          {
            RGBAttribute castB = attrB;
            if(castB == null)
              return false;

            RGB bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Scale_RGB(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Scale_RGB<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ColorAttribute:
          {
            ColorAttribute castB = attrB;
            if(castB == null)
              return false;

            Color bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_RGBA_Scale_Color(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_RGBA_Scale_Color<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
  }


  return false;
}
