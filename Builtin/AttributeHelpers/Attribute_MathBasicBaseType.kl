
/*
 *  Copyright (c) 2010-2017 Fabric Software Inc. All rights reserved.
 */

operator _MathBasic_SInt32_Add_SInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Sub_SInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Mul_SInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Div_SInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Min_SInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Max_SInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Interpolate_SInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_AddMul_SInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Scale_SInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_SubOne_SInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = SInt32(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Inv_SInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = SInt32(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Neg_SInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}


operator _MathBasic_SInt32_Add_UInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Sub_UInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Mul_UInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Div_UInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Min_UInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Max_UInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Interpolate_UInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_AddMul_UInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Scale_UInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_SubOne_UInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = SInt32(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Inv_UInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = SInt32(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Neg_UInt32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}


operator _MathBasic_SInt32_Add_Float32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Sub_Float32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Mul_Float32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Div_Float32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Min_Float32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Max_Float32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Interpolate_Float32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_AddMul_Float32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  SInt32 bb = useSingleValue ? typedValue : SInt32(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Scale_Float32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_SubOne_Float32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = SInt32(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Inv_Float32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = SInt32(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}

operator _MathBasic_SInt32_Neg_Float32<<<i>>>(
  io SInt32 result[],
  SInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  SInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    SInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - SInt32(range.x)) / SInt32(range.y - range.x);
  }
}


/// \internal
private function Boolean BaseGeometry.performMathBasicIntegerAttribute!(
  SInt32 mode,
  io GeometryAttributes attributes,
  GeometryAttribute attrA,
  GeometryAttribute attrB,
  String result,
  Scalar t,
  Boolean normalize,
  Vec2 range,
  Boolean useSingleValue,
  SInt32 typedValue
) {
  IntegerAttribute castA = attrA;
  if(castA == null)
    return false;
  SInt32 aValues[] = castA.values;

  GeometryAttribute resultAttr = attributes.getAttribute(result);
  if(resultAttr != null)
  {
    if(resultAttr.type() != IntegerAttribute)
    {
      report('Error: MathBasic: Result attribute "'+result+'" already exists, but of wrong type.');
      return false;
    }
  }
  IntegerAttribute castResult = attributes.getOrCreateIntegerAttribute(result);
  if(castResult == null)
    return false;
  SInt32 resultValues[] = castResult.values;

  switch(mode)
  {
    case 0: // Add
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_SInt32_Add_SInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_SInt32_Add_SInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Add_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Add_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Add_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Add_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Add_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Add_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 1: // Sub
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_SInt32_Sub_SInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_SInt32_Sub_SInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Sub_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Sub_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Sub_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Sub_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Sub_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Sub_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 2: // Mul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_SInt32_Mul_SInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_SInt32_Mul_SInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Mul_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Mul_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Mul_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Mul_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Mul_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Mul_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 3: // Div
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_SInt32_Div_SInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_SInt32_Div_SInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Div_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Div_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Div_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Div_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Div_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Div_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 4: // Min
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_SInt32_Min_SInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_SInt32_Min_SInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Min_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Min_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Min_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Min_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Min_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Min_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 5: // Max
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_SInt32_Max_SInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_SInt32_Max_SInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Max_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Max_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Max_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Max_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Max_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Max_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 6: // Interpolate
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_SInt32_Interpolate_SInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_SInt32_Interpolate_SInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Interpolate_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Interpolate_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Interpolate_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Interpolate_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Interpolate_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Interpolate_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 7: // AddMul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_SInt32_AddMul_SInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_SInt32_AddMul_SInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_AddMul_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_AddMul_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_AddMul_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_AddMul_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_AddMul_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_AddMul_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 10: // Scale
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_SInt32_Scale_SInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_SInt32_Scale_SInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Scale_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Scale_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Scale_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Scale_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Scale_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Scale_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 11: // SubOne
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_SInt32_SubOne_SInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_SInt32_SubOne_SInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_SubOne_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_SubOne_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_SubOne_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_SubOne_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_SubOne_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_SubOne_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 12: // Inv
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_SInt32_Inv_SInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_SInt32_Inv_SInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Inv_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Inv_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Inv_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Inv_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Inv_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Inv_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 13: // Neg
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_SInt32_Neg_SInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_SInt32_Neg_SInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Neg_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Neg_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Neg_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Neg_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_SInt32_Neg_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_SInt32_Neg_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
  }


  castResult.incrementVersion();
  return true;
}

operator _MathBasic_UInt32_Add_UInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Sub_UInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Mul_UInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Div_UInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Min_UInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Max_UInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Interpolate_UInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_AddMul_UInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Scale_UInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_SubOne_UInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = UInt32(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Inv_UInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = UInt32(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Neg_UInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}


operator _MathBasic_UInt32_Add_SInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Sub_SInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Mul_SInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Div_SInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Min_SInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Max_SInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Interpolate_SInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_AddMul_SInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Scale_SInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_SubOne_SInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = UInt32(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Inv_SInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = UInt32(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Neg_SInt32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}


operator _MathBasic_UInt32_Add_Float32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Sub_Float32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Mul_Float32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Div_Float32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Min_Float32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Max_Float32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Interpolate_Float32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_AddMul_Float32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  UInt32 bb = useSingleValue ? typedValue : UInt32(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Scale_Float32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_SubOne_Float32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = UInt32(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Inv_Float32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = UInt32(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}

operator _MathBasic_UInt32_Neg_Float32<<<i>>>(
  io UInt32 result[],
  UInt32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  UInt32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    UInt32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - UInt32(range.x)) / UInt32(range.y - range.x);
  }
}


/// \internal
private function Boolean BaseGeometry.performMathBasicUInt32Attribute!(
  SInt32 mode,
  io GeometryAttributes attributes,
  GeometryAttribute attrA,
  GeometryAttribute attrB,
  String result,
  Scalar t,
  Boolean normalize,
  Vec2 range,
  Boolean useSingleValue,
  UInt32 typedValue
) {
  UInt32Attribute castA = attrA;
  if(castA == null)
    return false;
  UInt32 aValues[] = castA.values;

  GeometryAttribute resultAttr = attributes.getAttribute(result);
  if(resultAttr != null)
  {
    if(resultAttr.type() != UInt32Attribute)
    {
      report('Error: MathBasic: Result attribute "'+result+'" already exists, but of wrong type.');
      return false;
    }
  }
  UInt32Attribute castResult = attributes.getOrCreateUInt32Attribute(result);
  if(castResult == null)
    return false;
  UInt32 resultValues[] = castResult.values;

  switch(mode)
  {
    case 0: // Add
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_UInt32_Add_UInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_UInt32_Add_UInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Add_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Add_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Add_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Add_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Add_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Add_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 1: // Sub
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_UInt32_Sub_UInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_UInt32_Sub_UInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Sub_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Sub_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Sub_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Sub_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Sub_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Sub_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 2: // Mul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_UInt32_Mul_UInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_UInt32_Mul_UInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Mul_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Mul_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Mul_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Mul_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Mul_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Mul_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 3: // Div
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_UInt32_Div_UInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_UInt32_Div_UInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Div_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Div_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Div_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Div_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Div_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Div_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 4: // Min
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_UInt32_Min_UInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_UInt32_Min_UInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Min_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Min_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Min_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Min_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Min_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Min_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 5: // Max
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_UInt32_Max_UInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_UInt32_Max_UInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Max_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Max_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Max_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Max_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Max_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Max_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 6: // Interpolate
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_UInt32_Interpolate_UInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_UInt32_Interpolate_UInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Interpolate_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Interpolate_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Interpolate_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Interpolate_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Interpolate_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Interpolate_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 7: // AddMul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_UInt32_AddMul_UInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_UInt32_AddMul_UInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_AddMul_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_AddMul_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_AddMul_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_AddMul_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_AddMul_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_AddMul_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 10: // Scale
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_UInt32_Scale_UInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_UInt32_Scale_UInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Scale_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Scale_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Scale_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Scale_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Scale_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Scale_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 11: // SubOne
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_UInt32_SubOne_UInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_UInt32_SubOne_UInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_SubOne_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_SubOne_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_SubOne_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_SubOne_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_SubOne_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_SubOne_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 12: // Inv
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_UInt32_Inv_UInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_UInt32_Inv_UInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Inv_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Inv_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Inv_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Inv_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Inv_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Inv_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 13: // Neg
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_UInt32_Neg_UInt32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_UInt32_Neg_UInt32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Neg_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Neg_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Neg_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Neg_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_UInt32_Neg_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_UInt32_Neg_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
  }


  castResult.incrementVersion();
  return true;
}

operator _MathBasic_Float32_Add_Float32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Sub_Float32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Mul_Float32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Div_Float32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Min_Float32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Max_Float32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Interpolate_Float32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_AddMul_Float32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Scale_Float32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_SubOne_Float32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Float32(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Inv_Float32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Float32(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Neg_Float32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}


operator _MathBasic_Float32_Add_SInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Sub_SInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Mul_SInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Div_SInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Min_SInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Max_SInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Interpolate_SInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_AddMul_SInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Scale_SInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_SubOne_SInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Float32(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Inv_SInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Float32(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Neg_SInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}


operator _MathBasic_Float32_Add_UInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Sub_UInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Mul_UInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Div_UInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Min_UInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Max_UInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Interpolate_UInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_AddMul_UInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  Float32 bb = useSingleValue ? typedValue : Float32(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Scale_UInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_SubOne_UInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Float32(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Inv_UInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Float32(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}

operator _MathBasic_Float32_Neg_UInt32<<<i>>>(
  io Float32 result[],
  Float32 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Float32 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    Float32 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Float32(range.x)) / Float32(range.y - range.x);
  }
}


/// \internal
private function Boolean BaseGeometry.performMathBasicScalarAttribute!(
  SInt32 mode,
  io GeometryAttributes attributes,
  GeometryAttribute attrA,
  GeometryAttribute attrB,
  String result,
  Scalar t,
  Boolean normalize,
  Vec2 range,
  Boolean useSingleValue,
  Float32 typedValue
) {
  ScalarAttribute castA = attrA;
  if(castA == null)
    return false;
  Float32 aValues[] = castA.values;

  GeometryAttribute resultAttr = attributes.getAttribute(result);
  if(resultAttr != null)
  {
    if(resultAttr.type() != ScalarAttribute)
    {
      report('Error: MathBasic: Result attribute "'+result+'" already exists, but of wrong type.');
      return false;
    }
  }
  ScalarAttribute castResult = attributes.getOrCreateScalarAttribute(result);
  if(castResult == null)
    return false;
  Float32 resultValues[] = castResult.values;

  switch(mode)
  {
    case 0: // Add
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Float32_Add_Float32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Float32_Add_Float32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Add_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Add_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Add_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Add_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Add_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Add_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 1: // Sub
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Float32_Sub_Float32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Float32_Sub_Float32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Sub_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Sub_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Sub_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Sub_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Sub_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Sub_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 2: // Mul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Float32_Mul_Float32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Float32_Mul_Float32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Mul_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Mul_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Mul_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Mul_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Mul_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Mul_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 3: // Div
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Float32_Div_Float32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Float32_Div_Float32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Div_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Div_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Div_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Div_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Div_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Div_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 4: // Min
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Float32_Min_Float32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Float32_Min_Float32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Min_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Min_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Min_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Min_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Min_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Min_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 5: // Max
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Float32_Max_Float32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Float32_Max_Float32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Max_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Max_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Max_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Max_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Max_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Max_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 6: // Interpolate
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Float32_Interpolate_Float32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Float32_Interpolate_Float32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Interpolate_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Interpolate_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Interpolate_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Interpolate_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Interpolate_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Interpolate_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 7: // AddMul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Float32_AddMul_Float32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Float32_AddMul_Float32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_AddMul_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_AddMul_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_AddMul_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_AddMul_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_AddMul_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_AddMul_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 10: // Scale
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Float32_Scale_Float32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Float32_Scale_Float32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Scale_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Scale_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Scale_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Scale_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Scale_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Scale_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 11: // SubOne
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Float32_SubOne_Float32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Float32_SubOne_Float32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_SubOne_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_SubOne_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_SubOne_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_SubOne_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_SubOne_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_SubOne_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 12: // Inv
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Float32_Inv_Float32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Float32_Inv_Float32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Inv_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Inv_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Inv_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Inv_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Inv_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Inv_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 13: // Neg
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Float32_Neg_Float32(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Float32_Neg_Float32<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Neg_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Neg_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Neg_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Neg_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Float32_Neg_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Float32_Neg_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
  }


  castResult.incrementVersion();
  return true;
}

operator _MathBasic_Vec2_Add_Vec2<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Vec2 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Sub_Vec2<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Vec2 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Mul_Vec2<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Vec2 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Div_Vec2<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Vec2 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Min_Vec2<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Vec2 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Max_Vec2<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Vec2 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Interpolate_Vec2<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Vec2 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_AddMul_Vec2<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Vec2 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Scale_Vec2<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Vec2 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_SubOne_Vec2<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Vec2 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec2(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Inv_Vec2<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Vec2 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec2(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Neg_Vec2<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Vec2 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}


operator _MathBasic_Vec2_Add_Float32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Sub_Float32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Mul_Float32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Div_Float32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Min_Float32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Max_Float32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Interpolate_Float32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_AddMul_Float32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Scale_Float32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_SubOne_Float32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec2(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Inv_Float32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec2(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Neg_Float32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}


operator _MathBasic_Vec2_Add_SInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Sub_SInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Mul_SInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Div_SInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Min_SInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Max_SInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Interpolate_SInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_AddMul_SInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Scale_SInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_SubOne_SInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec2(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Inv_SInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec2(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Neg_SInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}


operator _MathBasic_Vec2_Add_UInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Sub_UInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Mul_UInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Div_UInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Min_UInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Max_UInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Interpolate_UInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_AddMul_UInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  Vec2 bb = useSingleValue ? typedValue : Vec2(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Scale_UInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_SubOne_UInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec2(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Inv_UInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec2(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}

operator _MathBasic_Vec2_Neg_UInt32<<<i>>>(
  io Vec2 result[],
  Vec2 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec2 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    Vec2 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec2(range.x)) / Vec2(range.y - range.x);
  }
}


/// \internal
private function Boolean BaseGeometry.performMathBasicVec2Attribute!(
  SInt32 mode,
  io GeometryAttributes attributes,
  GeometryAttribute attrA,
  GeometryAttribute attrB,
  String result,
  Scalar t,
  Boolean normalize,
  Vec2 range,
  Boolean useSingleValue,
  Vec2 typedValue
) {
  Vec2Attribute castA = attrA;
  if(castA == null)
    return false;
  Vec2 aValues[] = castA.values;

  GeometryAttribute resultAttr = attributes.getAttribute(result);
  if(resultAttr != null)
  {
    if(resultAttr.type() != Vec2Attribute)
    {
      report('Error: MathBasic: Result attribute "'+result+'" already exists, but of wrong type.');
      return false;
    }
  }
  Vec2Attribute castResult = attributes.getOrCreateVec2Attribute(result);
  if(castResult == null)
    return false;
  Vec2 resultValues[] = castResult.values;

  switch(mode)
  {
    case 0: // Add
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec2_Add_Vec2(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec2_Add_Vec2<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec2Attribute:
          {
            Vec2Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec2 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Add_Vec2(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Add_Vec2<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Add_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Add_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Add_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Add_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Add_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Add_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 1: // Sub
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec2_Sub_Vec2(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec2_Sub_Vec2<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec2Attribute:
          {
            Vec2Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec2 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Sub_Vec2(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Sub_Vec2<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Sub_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Sub_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Sub_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Sub_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Sub_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Sub_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 2: // Mul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec2_Mul_Vec2(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec2_Mul_Vec2<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec2Attribute:
          {
            Vec2Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec2 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Mul_Vec2(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Mul_Vec2<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Mul_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Mul_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Mul_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Mul_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Mul_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Mul_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 3: // Div
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec2_Div_Vec2(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec2_Div_Vec2<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec2Attribute:
          {
            Vec2Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec2 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Div_Vec2(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Div_Vec2<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Div_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Div_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Div_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Div_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Div_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Div_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 4: // Min
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec2_Min_Vec2(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec2_Min_Vec2<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec2Attribute:
          {
            Vec2Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec2 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Min_Vec2(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Min_Vec2<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Min_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Min_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Min_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Min_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Min_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Min_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 5: // Max
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec2_Max_Vec2(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec2_Max_Vec2<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec2Attribute:
          {
            Vec2Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec2 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Max_Vec2(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Max_Vec2<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Max_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Max_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Max_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Max_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Max_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Max_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 6: // Interpolate
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec2_Interpolate_Vec2(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec2_Interpolate_Vec2<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec2Attribute:
          {
            Vec2Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec2 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Interpolate_Vec2(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Interpolate_Vec2<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Interpolate_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Interpolate_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Interpolate_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Interpolate_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Interpolate_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Interpolate_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 7: // AddMul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec2_AddMul_Vec2(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec2_AddMul_Vec2<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec2Attribute:
          {
            Vec2Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec2 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_AddMul_Vec2(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_AddMul_Vec2<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_AddMul_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_AddMul_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_AddMul_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_AddMul_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_AddMul_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_AddMul_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 10: // Scale
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec2_Scale_Vec2(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec2_Scale_Vec2<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec2Attribute:
          {
            Vec2Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec2 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Scale_Vec2(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Scale_Vec2<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Scale_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Scale_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Scale_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Scale_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Scale_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Scale_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 11: // SubOne
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec2_SubOne_Vec2(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec2_SubOne_Vec2<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec2Attribute:
          {
            Vec2Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec2 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_SubOne_Vec2(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_SubOne_Vec2<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_SubOne_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_SubOne_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_SubOne_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_SubOne_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_SubOne_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_SubOne_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 12: // Inv
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec2_Inv_Vec2(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec2_Inv_Vec2<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec2Attribute:
          {
            Vec2Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec2 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Inv_Vec2(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Inv_Vec2<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Inv_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Inv_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Inv_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Inv_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Inv_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Inv_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 13: // Neg
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec2_Neg_Vec2(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec2_Neg_Vec2<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec2Attribute:
          {
            Vec2Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec2 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Neg_Vec2(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Neg_Vec2<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Neg_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Neg_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Neg_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Neg_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec2_Neg_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec2_Neg_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
  }


  castResult.incrementVersion();
  return true;
}

operator _MathBasic_Vec3_Add_Vec3<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Vec3 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Sub_Vec3<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Vec3 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Mul_Vec3<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Vec3 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Div_Vec3<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Vec3 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Min_Vec3<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Vec3 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Max_Vec3<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Vec3 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Interpolate_Vec3<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Vec3 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_AddMul_Vec3<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Vec3 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Scale_Vec3<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Vec3 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_SubOne_Vec3<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Vec3 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec3(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Inv_Vec3<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Vec3 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec3(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Neg_Vec3<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Vec3 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}


operator _MathBasic_Vec3_Add_Float32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Sub_Float32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Mul_Float32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Div_Float32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Min_Float32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Max_Float32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Interpolate_Float32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_AddMul_Float32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Scale_Float32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_SubOne_Float32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec3(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Inv_Float32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec3(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Neg_Float32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}


operator _MathBasic_Vec3_Add_SInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Sub_SInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Mul_SInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Div_SInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Min_SInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Max_SInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Interpolate_SInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_AddMul_SInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Scale_SInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_SubOne_SInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec3(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Inv_SInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec3(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Neg_SInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}


operator _MathBasic_Vec3_Add_UInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Sub_UInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Mul_UInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Div_UInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Min_UInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Max_UInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Interpolate_UInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_AddMul_UInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  Vec3 bb = useSingleValue ? typedValue : Vec3(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Scale_UInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_SubOne_UInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec3(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Inv_UInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec3(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}

operator _MathBasic_Vec3_Neg_UInt32<<<i>>>(
  io Vec3 result[],
  Vec3 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec3 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    Vec3 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec3(range.x)) / Vec3(range.y - range.x);
  }
}


/// \internal
private function Boolean BaseGeometry.performMathBasicVec3Attribute!(
  SInt32 mode,
  io GeometryAttributes attributes,
  GeometryAttribute attrA,
  GeometryAttribute attrB,
  String result,
  Scalar t,
  Boolean normalize,
  Vec2 range,
  Boolean useSingleValue,
  Vec3 typedValue
) {
  Vec3Attribute castA = attrA;
  if(castA == null)
    return false;
  Vec3 aValues[] = castA.values;

  GeometryAttribute resultAttr = attributes.getAttribute(result);
  if(resultAttr != null)
  {
    if(resultAttr.type() != Vec3Attribute)
    {
      report('Error: MathBasic: Result attribute "'+result+'" already exists, but of wrong type.');
      return false;
    }
  }
  Vec3Attribute castResult = attributes.getOrCreateVec3Attribute(result);
  if(castResult == null)
    return false;
  Vec3 resultValues[] = castResult.values;

  switch(mode)
  {
    case 0: // Add
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec3_Add_Vec3(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec3_Add_Vec3<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec3Attribute:
          {
            Vec3Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec3 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Add_Vec3(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Add_Vec3<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Add_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Add_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Add_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Add_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Add_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Add_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 1: // Sub
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec3_Sub_Vec3(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec3_Sub_Vec3<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec3Attribute:
          {
            Vec3Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec3 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Sub_Vec3(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Sub_Vec3<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Sub_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Sub_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Sub_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Sub_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Sub_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Sub_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 2: // Mul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec3_Mul_Vec3(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec3_Mul_Vec3<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec3Attribute:
          {
            Vec3Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec3 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Mul_Vec3(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Mul_Vec3<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Mul_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Mul_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Mul_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Mul_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Mul_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Mul_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 3: // Div
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec3_Div_Vec3(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec3_Div_Vec3<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec3Attribute:
          {
            Vec3Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec3 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Div_Vec3(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Div_Vec3<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Div_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Div_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Div_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Div_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Div_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Div_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 4: // Min
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec3_Min_Vec3(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec3_Min_Vec3<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec3Attribute:
          {
            Vec3Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec3 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Min_Vec3(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Min_Vec3<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Min_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Min_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Min_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Min_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Min_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Min_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 5: // Max
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec3_Max_Vec3(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec3_Max_Vec3<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec3Attribute:
          {
            Vec3Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec3 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Max_Vec3(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Max_Vec3<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Max_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Max_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Max_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Max_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Max_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Max_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 6: // Interpolate
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec3_Interpolate_Vec3(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec3_Interpolate_Vec3<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec3Attribute:
          {
            Vec3Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec3 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Interpolate_Vec3(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Interpolate_Vec3<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Interpolate_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Interpolate_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Interpolate_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Interpolate_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Interpolate_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Interpolate_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 7: // AddMul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec3_AddMul_Vec3(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec3_AddMul_Vec3<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec3Attribute:
          {
            Vec3Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec3 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_AddMul_Vec3(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_AddMul_Vec3<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_AddMul_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_AddMul_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_AddMul_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_AddMul_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_AddMul_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_AddMul_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 10: // Scale
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec3_Scale_Vec3(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec3_Scale_Vec3<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec3Attribute:
          {
            Vec3Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec3 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Scale_Vec3(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Scale_Vec3<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Scale_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Scale_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Scale_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Scale_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Scale_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Scale_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 11: // SubOne
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec3_SubOne_Vec3(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec3_SubOne_Vec3<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec3Attribute:
          {
            Vec3Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec3 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_SubOne_Vec3(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_SubOne_Vec3<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_SubOne_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_SubOne_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_SubOne_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_SubOne_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_SubOne_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_SubOne_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 12: // Inv
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec3_Inv_Vec3(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec3_Inv_Vec3<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec3Attribute:
          {
            Vec3Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec3 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Inv_Vec3(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Inv_Vec3<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Inv_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Inv_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Inv_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Inv_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Inv_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Inv_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 13: // Neg
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec3_Neg_Vec3(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec3_Neg_Vec3<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec3Attribute:
          {
            Vec3Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec3 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Neg_Vec3(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Neg_Vec3<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Neg_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Neg_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Neg_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Neg_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec3_Neg_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec3_Neg_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
  }


  castResult.incrementVersion();
  return true;
}

operator _MathBasic_Vec4_Add_Vec4<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Vec4 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Sub_Vec4<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Vec4 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Mul_Vec4<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Vec4 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Div_Vec4<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Vec4 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Min_Vec4<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Vec4 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Max_Vec4<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Vec4 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Interpolate_Vec4<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Vec4 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_AddMul_Vec4<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Vec4 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Scale_Vec4<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Vec4 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_SubOne_Vec4<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Vec4 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec4(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Inv_Vec4<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Vec4 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec4(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Neg_Vec4<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Vec4 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}


operator _MathBasic_Vec4_Add_Float32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Sub_Float32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Mul_Float32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Div_Float32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Min_Float32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Max_Float32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Interpolate_Float32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_AddMul_Float32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Scale_Float32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_SubOne_Float32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec4(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Inv_Float32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec4(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Neg_Float32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  Float32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}


operator _MathBasic_Vec4_Add_SInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Sub_SInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Mul_SInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Div_SInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Min_SInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Max_SInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Interpolate_SInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_AddMul_SInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Scale_SInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_SubOne_SInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec4(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Inv_SInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec4(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Neg_SInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  SInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}


operator _MathBasic_Vec4_Add_UInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] + bb;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Sub_UInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] - bb;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Mul_UInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] * bb;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Div_UInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] / bb;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Min_UInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = Math_min(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Max_UInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = Math_max(a[i], bb);
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Interpolate_UInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i].linearInterpolate(bb, t);
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_AddMul_UInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  Vec4 bb = useSingleValue ? typedValue : Vec4(b[i]);
  result[i] = a[i] + bb * t;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Scale_UInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * t;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_SubOne_UInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec4(1.0) - a[i];
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Inv_UInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = Vec4(1.0) / a[i];
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}

operator _MathBasic_Vec4_Neg_UInt32<<<i>>>(
  io Vec4 result[],
  Vec4 a[],
  UInt32 b[],
  Float32 t,
  Boolean normalize,
  Vec2 range,
  Vec4 typedValue,
  Boolean useSingleValue
  ) {
  result[i] = a[i] * -1;
  if(normalize && range.y != range.x)
  {
    Vec4 v = Math_clamp(result[i], range.x < range.y ? range.x : range.y, range.x < range.y ? range.y : range.x);
    result[i] = (v - Vec4(range.x)) / Vec4(range.y - range.x);
  }
}


/// \internal
private function Boolean BaseGeometry.performMathBasicVec4Attribute!(
  SInt32 mode,
  io GeometryAttributes attributes,
  GeometryAttribute attrA,
  GeometryAttribute attrB,
  String result,
  Scalar t,
  Boolean normalize,
  Vec2 range,
  Boolean useSingleValue,
  Vec4 typedValue
) {
  Vec4Attribute castA = attrA;
  if(castA == null)
    return false;
  Vec4 aValues[] = castA.values;

  GeometryAttribute resultAttr = attributes.getAttribute(result);
  if(resultAttr != null)
  {
    if(resultAttr.type() != Vec4Attribute)
    {
      report('Error: MathBasic: Result attribute "'+result+'" already exists, but of wrong type.');
      return false;
    }
  }
  Vec4Attribute castResult = attributes.getOrCreateVec4Attribute(result);
  if(castResult == null)
    return false;
  Vec4 resultValues[] = castResult.values;

  switch(mode)
  {
    case 0: // Add
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec4_Add_Vec4(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec4_Add_Vec4<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec4Attribute:
          {
            Vec4Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec4 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Add_Vec4(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Add_Vec4<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Add_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Add_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Add_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Add_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Add_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Add_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 1: // Sub
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec4_Sub_Vec4(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec4_Sub_Vec4<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec4Attribute:
          {
            Vec4Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec4 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Sub_Vec4(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Sub_Vec4<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Sub_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Sub_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Sub_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Sub_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Sub_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Sub_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 2: // Mul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec4_Mul_Vec4(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec4_Mul_Vec4<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec4Attribute:
          {
            Vec4Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec4 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Mul_Vec4(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Mul_Vec4<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Mul_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Mul_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Mul_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Mul_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Mul_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Mul_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 3: // Div
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec4_Div_Vec4(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec4_Div_Vec4<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec4Attribute:
          {
            Vec4Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec4 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Div_Vec4(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Div_Vec4<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Div_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Div_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Div_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Div_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Div_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Div_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 4: // Min
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec4_Min_Vec4(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec4_Min_Vec4<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec4Attribute:
          {
            Vec4Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec4 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Min_Vec4(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Min_Vec4<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Min_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Min_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Min_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Min_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Min_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Min_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 5: // Max
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec4_Max_Vec4(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec4_Max_Vec4<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec4Attribute:
          {
            Vec4Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec4 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Max_Vec4(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Max_Vec4<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Max_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Max_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Max_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Max_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Max_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Max_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 6: // Interpolate
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec4_Interpolate_Vec4(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec4_Interpolate_Vec4<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec4Attribute:
          {
            Vec4Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec4 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Interpolate_Vec4(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Interpolate_Vec4<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Interpolate_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Interpolate_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Interpolate_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Interpolate_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Interpolate_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Interpolate_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 7: // AddMul
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec4_AddMul_Vec4(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec4_AddMul_Vec4<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec4Attribute:
          {
            Vec4Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec4 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_AddMul_Vec4(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_AddMul_Vec4<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_AddMul_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_AddMul_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_AddMul_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_AddMul_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_AddMul_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_AddMul_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 10: // Scale
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec4_Scale_Vec4(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec4_Scale_Vec4<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec4Attribute:
          {
            Vec4Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec4 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Scale_Vec4(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Scale_Vec4<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Scale_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Scale_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Scale_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Scale_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Scale_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Scale_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 11: // SubOne
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec4_SubOne_Vec4(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec4_SubOne_Vec4<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec4Attribute:
          {
            Vec4Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec4 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_SubOne_Vec4(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_SubOne_Vec4<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_SubOne_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_SubOne_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_SubOne_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_SubOne_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_SubOne_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_SubOne_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 12: // Inv
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec4_Inv_Vec4(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec4_Inv_Vec4<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec4Attribute:
          {
            Vec4Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec4 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Inv_Vec4(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Inv_Vec4<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Inv_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Inv_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Inv_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Inv_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Inv_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Inv_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
    case 13: // Neg
    {
      if(useSingleValue)
      {
        if(aValues.size() < Attribute_Pex_Margin)
        {
          for(Index index=0;index<aValues.size();index++)
          {
            _MathBasic_Vec4_Neg_Vec4(
              index, 
              resultValues,
              aValues,
              aValues, // ignore b
              t,
              normalize,
              range,
              typedValue,
              true
            );
          }
        }
        else
        {
          _MathBasic_Vec4_Neg_Vec4<<<aValues.size()>>>(
            resultValues,
            aValues,
            aValues, // ignore b
            t,
            normalize,
            range,
            typedValue,
            true
          );
        }
      }
      else
      {
        switch(attrB.type())
        {
          case Vec4Attribute:
          {
            Vec4Attribute castB = attrB;
            if(castB == null)
              return false;

            Vec4 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Neg_Vec4(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Neg_Vec4<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case ScalarAttribute:
          {
            ScalarAttribute castB = attrB;
            if(castB == null)
              return false;

            Float32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Neg_Float32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Neg_Float32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case IntegerAttribute:
          {
            IntegerAttribute castB = attrB;
            if(castB == null)
              return false;

            SInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Neg_SInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Neg_SInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }
          case UInt32Attribute:
          {
            UInt32Attribute castB = attrB;
            if(castB == null)
              return false;

            UInt32 bValues[] = castB.values;
            if(aValues.size() < Attribute_Pex_Margin)
            {
              for(Index index=0;index<aValues.size();index++)
              {
                _MathBasic_Vec4_Neg_UInt32(
                  index, 
                  resultValues,
                  aValues,
                  bValues,
                  t,
                  normalize,
                  range,
                  typedValue,
                  false
                );
              }
            }
            else
            {
              _MathBasic_Vec4_Neg_UInt32<<<aValues.size()>>>(
                resultValues,
                aValues,
                bValues,
                t,
                normalize,
                range,
                typedValue,
                false
              );
            }
            break;
          }

          default:
          {
            report('Error: MathBasic: B attribute of type '+attrB.type()+' not supported for this mode.');
            return false;
          }
        }
      }

      break;
    }
  }


  castResult.incrementVersion();
  return true;
}
