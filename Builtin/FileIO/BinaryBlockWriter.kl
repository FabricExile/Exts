/*
 *  Copyright (c) 2010-2017 Fabric Software Inc. All rights reserved.
 */
/**
\versionadded 1.12.0

The BinaryBlockWriter provides a block based hierarchical binary file writing layer on top of the lower level BinaryWriter object.

\seealso BinaryBlockReader, BinaryBlockIO

\example
  FilePath path = FilePath('${TEMP}/binaryBlockWriter.bin').expandEnvVars();
  {
    BinaryBlockWriter blockWriter(path.string());
    blockWriter.setNumBlocks(3);

    BinaryBlockWriter section1Writer = blockWriter.beginWriteBlock('section1');

    String text = "some text";
    SInt32 textLength = text.length();

    report('section1:' + text);
    section1Writer.write(textLength.data, textLength.dataSize);
    section1Writer.write(text.data, text.dataSize);

    BinaryBlockWriter section2Writer = blockWriter.beginWriteBlock('section2');
    Float64 floats[];
    floats.resize(10);
    for(SInt32 i=0;i<floats.size();i++)
      floats[i] = Float64(i) * 17 + 1;
    SInt32 floatsSize = floats.size();

    report('section2:' + floats);
    section2Writer.write(floatsSize.data, floatsSize.dataSize);
    section2Writer.write(floats.data, floats.dataSize);


    BinaryBlockWriter section3Writer = blockWriter.beginWriteBlock('section3', 3);
    BinaryBlockWriter section3subSection1Writer = section3Writer.beginWriteBlock('subSection1');
    SInt32 ints[];
    ints.resize(10);
    for(SInt32 i=0;i<ints.size();i++)
      ints[i] = SInt32(i) * 17 + 1;
    SInt32 intsSize = ints.size();

    report('section3:' + ints);
    section2Writer.write(intsSize.data, intsSize.dataSize);
    section2Writer.write(ints.data, ints.dataSize);

    BinaryBlockWriter section3subSection2Writer = section3Writer.beginWriteBlock('subSection2');
    BinaryBlockWriter section3subSection3Writer = section3Writer.beginWriteBlock('subSection3');

    report('Binary file written.');
  }
\endexample
*/
object BinaryBlockWriter {
  /// \internal
  UInt64 tocPos;
  /// \internal
  UInt64 numBlocks;
  /// \internal
  UInt64 blockIndex;
  /// \internal
  UInt64 toc[String];
  /// \internal
  BinaryWriter writer;
};

/// standard constructor given a filepath
function BinaryBlockWriter(String filePath){
  this.writer = BinaryWriter(filePath);
}

/// constructor taking an existing BinaryWriter
function BinaryBlockWriter(out BinaryWriter writer){
  if(!writer.isOpen()){
    setError("BinaryBlockWriter constructed as a writer using an invalid BinaryWriter");
    return;
  }
  this.writer = writer;
  this.tocPos = this.writer.pos();
  this.setNumBlocks(0);
}

/// constructor taking an existing BinaryWriter and the number of blocks to write
function BinaryBlockWriter(out BinaryWriter writer, UInt32 numBlocks){
  if(!writer.isOpen()){
    setError("BinaryBlockWriter constructed as a writer using an invalid BinaryWriter");
    return;
  }
  this.writer = writer;
  this.tocPos = this.writer.pos();
  this.setNumBlocks(numBlocks);
}

/// sets the number of blocks this writer will be able to store
function BinaryBlockWriter.setNumBlocks!(UInt32 numBlocks){
  this.numBlocks = numBlocks;
  this.blockIndex = 0;

  // Write out a temporary header to allocate space for the toc.
  String names[];
  UInt64 offsets[];
  names.resize(numBlocks);
  offsets.resize(numBlocks);
  for(UInt32 i=0; i<numBlocks; i++){
    names.push('1234567890123456789012345678901234567890');
    offsets.push(-1);
  }
  this.writer.seek(this.tocPos);
  this.writer.writeStringArray(names);
  this.writer.write(offsets.data(), offsets.dataSize());
}

/// starts writing of one named block with a given number of sub blocks.
/// \seealso BinaryBlockWriter.write
function BinaryBlockWriter BinaryBlockWriter.beginWriteBlock!(String name, UInt32 numSubBlocks){
  BinaryBlockWriter blockWriter = null;
  if(!this.writer){
    setError("Error writing name: " + name + ". BinaryBlockWriter was not constructed as a writer");
    return blockWriter;
  }
  if(this.toc.has(name)){
    // Re-writing a block.
    this.writer.seek(this.toc[name]);
    BinaryWriter writer = this.writer;
    blockWriter = BinaryBlockWriter(writer, numSubBlocks);
    return blockWriter;
  }
  else{
    if(this.blockIndex>=this.numBlocks){
      report("WARNING: BinaryBlockWriter was not initilized with enough names. Adding name:" + name);
    }
    if(name.length() > 40){
      setError("name must be a maximum of 40 chars");
      // Note: we continue writing, because it will only fail on the read.
      // Other errors may be generated by continueing writing, and help with debugging
    }
    this.toc[name] = this.writer.pos();
    this.blockIndex++;
    BinaryWriter writer = this.writer;
    blockWriter = BinaryBlockWriter(writer, numSubBlocks);
    return blockWriter;
  }
}

/// An overload of the previous method, using 0 subblocks.
function BinaryBlockWriter BinaryBlockWriter.beginWriteBlock!(String name){
  return this.beginWriteBlock(name, 0);
}

/// performs the writing of the TOC once the writer is destroyed
/// \internal
function BinaryBlockWriter.writeToc!(){
  // when the writer goes out of scope, write the toc.
  UInt64 pos = this.writer.pos();
  this.writer.seek(this.tocPos);
  String names[];
  UInt64 offsets[];
  for(name, offset in this.toc){
    names.push(name);
    offsets.push(offset);
  }
  this.writer.writeStringArray(names);
  this.writer.write(offsets.data(), offsets.dataSize());
  this.writer.seek(pos);
}

/// standard destructor
function ~BinaryBlockWriter(){
  this.writeToc();
}

/// returns the wrapped BinaryWriter object
function BinaryWriter BinaryBlockWriter.getWriter(){
  return this.writer;
}

/// writes an array into the block
/// \param data The data pointer of the array
/// \param dataSize The dataSize result of the array
function BinaryBlockWriter.write!(Data data, UInt64 dataSize){
  this.writer.write(data, dataSize);
}

/// closes the wrapped BinaryWriter and releases the file handle
function BinaryBlockWriter.close!(){
  this.writer.close();
}

