// THIS FILE HAS BEEN GENERATED BY A SCONSCRIPT, FROM THE TEMPLATE : AlembicHelpers.template.kl 



/// \internal
Boolean AlembicGeometryParamReader.readSampleFloat32!(Float64 time, Float32 valuesA<>, UInt32 optionalPointToIndex<>, io GeometryAttributes attributes) {

  ScalarAttribute attr = attributes.getOrCreateScalarAttribute(this._name);

  AlembicIFloat32GeomParamSample sampleB = null;
  Float32 valuesB<>;

  // If interpolation is required, but the topology changes, round to the nearest frame
  if( this._info.requiresInterpolation() ) {
    sampleB = this._Float32Param.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getValsVolatileData();
    if( valuesA.size() != valuesB.size() )
      this._info.roundToClosestFrame();
  }

  Size sampleSize = valuesA.size();
  if( !optionalPointToIndex ) {
    Size count = Math_min( sampleSize, attr.size() );
    if( this._info.requiresInterpolation() ) {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i].linearInterpolate(valuesB[i], Float32(this._info.fraction));
    } else {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i];
    }
  } else {
    Size count = Math_min( optionalPointToIndex.size(), attr.size() );
    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index].linearInterpolate( valuesB[index], Float32( this._info.fraction ) );
      }
    } else {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index];
      }
    }
  }

  // if( !optionalPointToIndex && sampleSize != attr.size() ) {
  //   String name = this.getName();
  //   String originalName = this._Float32Param.getName();
  //   if( name != originalName ) { name = "\"" + name + "\" (originally \"" + originalName +"\")"; }
  //   else { name = "\"" + name + "\""; }
  //   report( "AlembicGeometryParamReader.readSampleFloat32 : Warning : reading the attribute " + name + " of size " + sampleSize
  //     + " in a GeometryAttribute of size " + attr.size() + " (" + ( sampleSize > attr.size() ? "truncating" : "padding") + " it). Archive : " + this.archive.getPath() );
  // }
  attr.incrementVersion();
  return true;
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleFloat32!( Float64 time, io GeometryAttributes attributes ) {
  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicIFloat32GeomParamSample sample = this._Float32Param.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  Float32 valuesA<> = sample.getValsVolatileData();

  UInt32 mapping<>;
  return this.readSampleFloat32( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readCurveSampleFloat32!( Float64 time, UInt32 curveCount, UInt32 pointToCurve<>, UInt32 optionalPointToIndex<>, io GeometryAttributes attributes ) {

  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicIFloat32GeomParamSample sample = this._Float32Param.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  Float32 valuesA<> = sample.getValsVolatileData();

  UInt32 mapping<>;
  if( valuesA.size() >= attributes.size() )
    mapping = optionalPointToIndex;
  else if( valuesA.size() >= curveCount )
    mapping = pointToCurve;

  return this.readSampleFloat32( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleFloat32!(Float64 time, io PolygonMesh mesh, Boolean keepSameAttributeIndices) {

  if(this._info.time == time || this._numSamples == 0)
    return false;

  AlembicSampleInfo info(time, this._timeSampling, this._numSamples);
  if(info == this._info)
    return false;
  this._info = info;

  Float32 valuesA<>;
  Float32 valuesB<>;
  Ref<ScalarAttribute> attr = mesh.getOrCreateScalarAttribute(this._name);
  AlembicIFloat32GeomParamSample sample = this._Float32Param.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  valuesA = sample.getValsVolatileData();
  AlembicIFloat32GeomParamSample sampleB = null;//Ensure its scope covers the values' lifetime

  if(this._info.requiresInterpolation()) {
    sampleB = this._Float32Param.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getValsVolatileData();
  }

  if(this._scope == Alembic_kVertexScope || this._scope == Alembic_kVaryingScope) {

    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i].linearInterpolate(valuesB[i], Float32(this._info.fraction)));
    } else {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i]);
    }

  } else if(this._scope == Alembic_kFacevaryingScope || this._scope == Alembic_kUniformScope) {

    Size offset = 0;
    for(Size i=0;i<mesh.polygonCount();i++) {
      Size count = mesh.getPolygonSize(i);
      for(UInt32 j=0;j<count;j++) {
        Float32 value = this._info.requiresInterpolation() ? valuesA[offset].linearInterpolate(valuesB[offset], Float32(this._info.fraction)) : valuesA[offset];
        if( keepSameAttributeIndices ) {
          UInt32 index = mesh.getPolygonAttributeIndex( i, count - 1 - j );
          attr.values[index] = value;
        } else
          mesh.setPolygonAttribute( i, count - 1 - j, attr, value );
        if( this._scope == Alembic_kFacevaryingScope ) { offset++; } // One value per corner of the polygon
      }
      if( this._scope == Alembic_kUniformScope ) { offset++; } // One value per polygon
    }
  }

  attr.incrementVersion();
  return true;
}

private AlembicGeometryParamReader.set!( AlembicIFloat32GeomParam param ) {
  this._name = param.getName();
  if(this._name.startsWith('.'))
    this._name = this._name.leftStrip(1);
  this._paramType = "Float32";
  this._Float32Param = param;
  this._timeSampling = this._Float32Param.getTimeSampling();
  this._numSamples = this._Float32Param.getNumSamples();
  this._scope = this._Float32Param.getScope();
}

/// Constructor for AlembicIFloat32GeomParam
public AlembicGeometryParamReader( AlembicArchiveReader archive, AlembicIFloat32GeomParam param ) {
  this.archive = archive;
  this.set( param );
}

/// \internal
private AlembicGeometryParamWriter.initFloat32!(
  AlembicOCompoundProperty parent,
  String name,
  AlembicGeometryScope scope,
  SInt32 timeSampling,
  Ref<ScalarAttribute> attribute
)
{
  this._name = name;
  this._paramType = "Float32";
  this._scope = scope;
  this._Float32Param = AlembicOFloat32GeomParam(parent, name, false, scope, 1);
  this._Float32Param.setTimeSampling(timeSampling);
  this._valueProperty = this._Float32Param.getValueProperty();
}

/// \internal
private Boolean AlembicGeometryParamWriter.writeSampleFloat32!(
  Ref<Geometry> geometry,
  Ref<GeometryAttribute> attribute,
  UInt32 optionalPointToIndex<>
)
{
  ScalarAttribute castAttribute = attribute;
  if( castAttribute == null )
    throw 'AlembicGeometryParamWriter: Attribute "'+this._name+'",  type and paramType "'+this._paramType+'" not matching.';

  Float32 values[] = castAttribute.values;
  if(this._scope == Alembic_kVertexScope)
  {
    if(geometry != null)
    {
      PolygonMesh mesh(geometry);
      if(mesh)
      {
        values = values.clone();
        values.resize(mesh.pointCount());
      }
    }
  }
  
  if( !optionalPointToIndex )
    this._Float32Param.set( AlembicOFloat32GeomParamSample( values, this._scope ) );
  else
  {
    Float32 mappedValues[]; mappedValues.resize( optionalPointToIndex.size() );
    
    for( Index i=0; i<mappedValues.size(); i++ )
      mappedValues[i] = values[ optionalPointToIndex[i] ];

    this._Float32Param.set( AlembicOFloat32GeomParamSample( mappedValues, this._scope ) );
  }

  return true;
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleUInt32!(Float64 time, UInt32 valuesA<>, UInt32 optionalPointToIndex<>, io GeometryAttributes attributes) {

  UInt32Attribute attr = attributes.getOrCreateUInt32Attribute(this._name);

  AlembicIUInt32GeomParamSample sampleB = null;
  UInt32 valuesB<>;

  // If interpolation is required, but the topology changes, round to the nearest frame
  if( this._info.requiresInterpolation() ) {
    sampleB = this._UInt32Param.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getValsVolatileData();
    if( valuesA.size() != valuesB.size() )
      this._info.roundToClosestFrame();
  }

  Size sampleSize = valuesA.size();
  if( !optionalPointToIndex ) {
    Size count = Math_min( sampleSize, attr.size() );
    if( this._info.requiresInterpolation() ) {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i].linearInterpolate(valuesB[i], Float32(this._info.fraction));
    } else {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i];
    }
  } else {
    Size count = Math_min( optionalPointToIndex.size(), attr.size() );
    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index].linearInterpolate( valuesB[index], Float32( this._info.fraction ) );
      }
    } else {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index];
      }
    }
  }

  // if( !optionalPointToIndex && sampleSize != attr.size() ) {
  //   String name = this.getName();
  //   String originalName = this._UInt32Param.getName();
  //   if( name != originalName ) { name = "\"" + name + "\" (originally \"" + originalName +"\")"; }
  //   else { name = "\"" + name + "\""; }
  //   report( "AlembicGeometryParamReader.readSampleUInt32 : Warning : reading the attribute " + name + " of size " + sampleSize
  //     + " in a GeometryAttribute of size " + attr.size() + " (" + ( sampleSize > attr.size() ? "truncating" : "padding") + " it). Archive : " + this.archive.getPath() );
  // }
  attr.incrementVersion();
  return true;
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleUInt32!( Float64 time, io GeometryAttributes attributes ) {
  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicIUInt32GeomParamSample sample = this._UInt32Param.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  UInt32 valuesA<> = sample.getValsVolatileData();

  UInt32 mapping<>;
  return this.readSampleUInt32( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readCurveSampleUInt32!( Float64 time, UInt32 curveCount, UInt32 pointToCurve<>, UInt32 optionalPointToIndex<>, io GeometryAttributes attributes ) {

  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicIUInt32GeomParamSample sample = this._UInt32Param.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  UInt32 valuesA<> = sample.getValsVolatileData();

  UInt32 mapping<>;
  if( valuesA.size() >= attributes.size() )
    mapping = optionalPointToIndex;
  else if( valuesA.size() >= curveCount )
    mapping = pointToCurve;

  return this.readSampleUInt32( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleUInt32!(Float64 time, io PolygonMesh mesh, Boolean keepSameAttributeIndices) {

  if(this._info.time == time || this._numSamples == 0)
    return false;

  AlembicSampleInfo info(time, this._timeSampling, this._numSamples);
  if(info == this._info)
    return false;
  this._info = info;

  UInt32 valuesA<>;
  UInt32 valuesB<>;
  Ref<UInt32Attribute> attr = mesh.getOrCreateUInt32Attribute(this._name);
  AlembicIUInt32GeomParamSample sample = this._UInt32Param.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  valuesA = sample.getValsVolatileData();
  AlembicIUInt32GeomParamSample sampleB = null;//Ensure its scope covers the values' lifetime

  if(this._info.requiresInterpolation()) {
    sampleB = this._UInt32Param.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getValsVolatileData();
  }

  if(this._scope == Alembic_kVertexScope || this._scope == Alembic_kVaryingScope) {

    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i].linearInterpolate(valuesB[i], Float32(this._info.fraction)));
    } else {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i]);
    }

  } else if(this._scope == Alembic_kFacevaryingScope || this._scope == Alembic_kUniformScope) {

    Size offset = 0;
    for(Size i=0;i<mesh.polygonCount();i++) {
      Size count = mesh.getPolygonSize(i);
      for(UInt32 j=0;j<count;j++) {
        UInt32 value = this._info.requiresInterpolation() ? valuesA[offset].linearInterpolate(valuesB[offset], Float32(this._info.fraction)) : valuesA[offset];
        if( keepSameAttributeIndices ) {
          UInt32 index = mesh.getPolygonAttributeIndex( i, count - 1 - j );
          attr.values[index] = value;
        } else
          mesh.setPolygonAttribute( i, count - 1 - j, attr, value );
        if( this._scope == Alembic_kFacevaryingScope ) { offset++; } // One value per corner of the polygon
      }
      if( this._scope == Alembic_kUniformScope ) { offset++; } // One value per polygon
    }
  }

  attr.incrementVersion();
  return true;
}

private AlembicGeometryParamReader.set!( AlembicIUInt32GeomParam param ) {
  this._name = param.getName();
  if(this._name.startsWith('.'))
    this._name = this._name.leftStrip(1);
  this._paramType = "UInt32";
  this._UInt32Param = param;
  this._timeSampling = this._UInt32Param.getTimeSampling();
  this._numSamples = this._UInt32Param.getNumSamples();
  this._scope = this._UInt32Param.getScope();
}

/// Constructor for AlembicIUInt32GeomParam
public AlembicGeometryParamReader( AlembicArchiveReader archive, AlembicIUInt32GeomParam param ) {
  this.archive = archive;
  this.set( param );
}

/// \internal
private AlembicGeometryParamWriter.initUInt32!(
  AlembicOCompoundProperty parent,
  String name,
  AlembicGeometryScope scope,
  SInt32 timeSampling,
  Ref<UInt32Attribute> attribute
)
{
  this._name = name;
  this._paramType = "UInt32";
  this._scope = scope;
  this._UInt32Param = AlembicOUInt32GeomParam(parent, name, false, scope, 1);
  this._UInt32Param.setTimeSampling(timeSampling);
  this._valueProperty = this._UInt32Param.getValueProperty();
}

/// \internal
private Boolean AlembicGeometryParamWriter.writeSampleUInt32!(
  Ref<Geometry> geometry,
  Ref<GeometryAttribute> attribute,
  UInt32 optionalPointToIndex<>
)
{
  UInt32Attribute castAttribute = attribute;
  if( castAttribute == null )
    throw 'AlembicGeometryParamWriter: Attribute "'+this._name+'",  type and paramType "'+this._paramType+'" not matching.';

  UInt32 values[] = castAttribute.values;
  if(this._scope == Alembic_kVertexScope)
  {
    if(geometry != null)
    {
      PolygonMesh mesh(geometry);
      if(mesh)
      {
        values = values.clone();
        values.resize(mesh.pointCount());
      }
    }
  }
  
  if( !optionalPointToIndex )
    this._UInt32Param.set( AlembicOUInt32GeomParamSample( values, this._scope ) );
  else
  {
    UInt32 mappedValues[]; mappedValues.resize( optionalPointToIndex.size() );
    
    for( Index i=0; i<mappedValues.size(); i++ )
      mappedValues[i] = values[ optionalPointToIndex[i] ];

    this._UInt32Param.set( AlembicOUInt32GeomParamSample( mappedValues, this._scope ) );
  }

  return true;
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleSInt32!(Float64 time, SInt32 valuesA<>, UInt32 optionalPointToIndex<>, io GeometryAttributes attributes) {

  IntegerAttribute attr = attributes.getOrCreateIntegerAttribute(this._name);

  AlembicISInt32GeomParamSample sampleB = null;
  SInt32 valuesB<>;

  // If interpolation is required, but the topology changes, round to the nearest frame
  if( this._info.requiresInterpolation() ) {
    sampleB = this._SInt32Param.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getValsVolatileData();
    if( valuesA.size() != valuesB.size() )
      this._info.roundToClosestFrame();
  }

  Size sampleSize = valuesA.size();
  if( !optionalPointToIndex ) {
    Size count = Math_min( sampleSize, attr.size() );
    if( this._info.requiresInterpolation() ) {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i].linearInterpolate(valuesB[i], Float32(this._info.fraction));
    } else {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i];
    }
  } else {
    Size count = Math_min( optionalPointToIndex.size(), attr.size() );
    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index].linearInterpolate( valuesB[index], Float32( this._info.fraction ) );
      }
    } else {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index];
      }
    }
  }

  // if( !optionalPointToIndex && sampleSize != attr.size() ) {
  //   String name = this.getName();
  //   String originalName = this._SInt32Param.getName();
  //   if( name != originalName ) { name = "\"" + name + "\" (originally \"" + originalName +"\")"; }
  //   else { name = "\"" + name + "\""; }
  //   report( "AlembicGeometryParamReader.readSampleSInt32 : Warning : reading the attribute " + name + " of size " + sampleSize
  //     + " in a GeometryAttribute of size " + attr.size() + " (" + ( sampleSize > attr.size() ? "truncating" : "padding") + " it). Archive : " + this.archive.getPath() );
  // }
  attr.incrementVersion();
  return true;
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleSInt32!( Float64 time, io GeometryAttributes attributes ) {
  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicISInt32GeomParamSample sample = this._SInt32Param.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  SInt32 valuesA<> = sample.getValsVolatileData();

  UInt32 mapping<>;
  return this.readSampleSInt32( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readCurveSampleSInt32!( Float64 time, UInt32 curveCount, UInt32 pointToCurve<>, UInt32 optionalPointToIndex<>, io GeometryAttributes attributes ) {

  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicISInt32GeomParamSample sample = this._SInt32Param.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  SInt32 valuesA<> = sample.getValsVolatileData();

  UInt32 mapping<>;
  if( valuesA.size() >= attributes.size() )
    mapping = optionalPointToIndex;
  else if( valuesA.size() >= curveCount )
    mapping = pointToCurve;

  return this.readSampleSInt32( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleSInt32!(Float64 time, io PolygonMesh mesh, Boolean keepSameAttributeIndices) {

  if(this._info.time == time || this._numSamples == 0)
    return false;

  AlembicSampleInfo info(time, this._timeSampling, this._numSamples);
  if(info == this._info)
    return false;
  this._info = info;

  SInt32 valuesA<>;
  SInt32 valuesB<>;
  Ref<IntegerAttribute> attr = mesh.getOrCreateIntegerAttribute(this._name);
  AlembicISInt32GeomParamSample sample = this._SInt32Param.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  valuesA = sample.getValsVolatileData();
  AlembicISInt32GeomParamSample sampleB = null;//Ensure its scope covers the values' lifetime

  if(this._info.requiresInterpolation()) {
    sampleB = this._SInt32Param.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getValsVolatileData();
  }

  if(this._scope == Alembic_kVertexScope || this._scope == Alembic_kVaryingScope) {

    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i].linearInterpolate(valuesB[i], Float32(this._info.fraction)));
    } else {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i]);
    }

  } else if(this._scope == Alembic_kFacevaryingScope || this._scope == Alembic_kUniformScope) {

    Size offset = 0;
    for(Size i=0;i<mesh.polygonCount();i++) {
      Size count = mesh.getPolygonSize(i);
      for(UInt32 j=0;j<count;j++) {
        SInt32 value = this._info.requiresInterpolation() ? valuesA[offset].linearInterpolate(valuesB[offset], Float32(this._info.fraction)) : valuesA[offset];
        if( keepSameAttributeIndices ) {
          UInt32 index = mesh.getPolygonAttributeIndex( i, count - 1 - j );
          attr.values[index] = value;
        } else
          mesh.setPolygonAttribute( i, count - 1 - j, attr, value );
        if( this._scope == Alembic_kFacevaryingScope ) { offset++; } // One value per corner of the polygon
      }
      if( this._scope == Alembic_kUniformScope ) { offset++; } // One value per polygon
    }
  }

  attr.incrementVersion();
  return true;
}

private AlembicGeometryParamReader.set!( AlembicISInt32GeomParam param ) {
  this._name = param.getName();
  if(this._name.startsWith('.'))
    this._name = this._name.leftStrip(1);
  this._paramType = "SInt32";
  this._SInt32Param = param;
  this._timeSampling = this._SInt32Param.getTimeSampling();
  this._numSamples = this._SInt32Param.getNumSamples();
  this._scope = this._SInt32Param.getScope();
}

/// Constructor for AlembicISInt32GeomParam
public AlembicGeometryParamReader( AlembicArchiveReader archive, AlembicISInt32GeomParam param ) {
  this.archive = archive;
  this.set( param );
}

/// \internal
private AlembicGeometryParamWriter.initSInt32!(
  AlembicOCompoundProperty parent,
  String name,
  AlembicGeometryScope scope,
  SInt32 timeSampling,
  Ref<IntegerAttribute> attribute
)
{
  this._name = name;
  this._paramType = "SInt32";
  this._scope = scope;
  this._SInt32Param = AlembicOSInt32GeomParam(parent, name, false, scope, 1);
  this._SInt32Param.setTimeSampling(timeSampling);
  this._valueProperty = this._SInt32Param.getValueProperty();
}

/// \internal
private Boolean AlembicGeometryParamWriter.writeSampleSInt32!(
  Ref<Geometry> geometry,
  Ref<GeometryAttribute> attribute,
  UInt32 optionalPointToIndex<>
)
{
  IntegerAttribute castAttribute = attribute;
  if( castAttribute == null )
    throw 'AlembicGeometryParamWriter: Attribute "'+this._name+'",  type and paramType "'+this._paramType+'" not matching.';

  SInt32 values[] = castAttribute.values;
  if(this._scope == Alembic_kVertexScope)
  {
    if(geometry != null)
    {
      PolygonMesh mesh(geometry);
      if(mesh)
      {
        values = values.clone();
        values.resize(mesh.pointCount());
      }
    }
  }
  
  if( !optionalPointToIndex )
    this._SInt32Param.set( AlembicOSInt32GeomParamSample( values, this._scope ) );
  else
  {
    SInt32 mappedValues[]; mappedValues.resize( optionalPointToIndex.size() );
    
    for( Index i=0; i<mappedValues.size(); i++ )
      mappedValues[i] = values[ optionalPointToIndex[i] ];

    this._SInt32Param.set( AlembicOSInt32GeomParamSample( mappedValues, this._scope ) );
  }

  return true;
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleVec2Vf!(Float64 time, Vec2 valuesA<>, UInt32 optionalPointToIndex<>, io GeometryAttributes attributes) {

  Vec2Attribute attr = attributes.getOrCreateVec2Attribute(this._name);

  AlembicIVec2VfGeomParamSample sampleB = null;
  Vec2 valuesB<>;

  // If interpolation is required, but the topology changes, round to the nearest frame
  if( this._info.requiresInterpolation() ) {
    sampleB = this._Vec2VfParam.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getValsVolatileData();
    if( valuesA.size() != valuesB.size() )
      this._info.roundToClosestFrame();
  }

  Size sampleSize = valuesA.size();
  if( !optionalPointToIndex ) {
    Size count = Math_min( sampleSize, attr.size() );
    if( this._info.requiresInterpolation() ) {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i].linearInterpolate(valuesB[i], Float32(this._info.fraction));
    } else {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i];
    }
  } else {
    Size count = Math_min( optionalPointToIndex.size(), attr.size() );
    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index].linearInterpolate( valuesB[index], Float32( this._info.fraction ) );
      }
    } else {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index];
      }
    }
  }

  // if( !optionalPointToIndex && sampleSize != attr.size() ) {
  //   String name = this.getName();
  //   String originalName = this._Vec2VfParam.getName();
  //   if( name != originalName ) { name = "\"" + name + "\" (originally \"" + originalName +"\")"; }
  //   else { name = "\"" + name + "\""; }
  //   report( "AlembicGeometryParamReader.readSampleVec2Vf : Warning : reading the attribute " + name + " of size " + sampleSize
  //     + " in a GeometryAttribute of size " + attr.size() + " (" + ( sampleSize > attr.size() ? "truncating" : "padding") + " it). Archive : " + this.archive.getPath() );
  // }
  attr.incrementVersion();
  return true;
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleVec2Vf!( Float64 time, io GeometryAttributes attributes ) {
  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicIVec2VfGeomParamSample sample = this._Vec2VfParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  Vec2 valuesA<> = sample.getValsVolatileData();

  UInt32 mapping<>;
  return this.readSampleVec2Vf( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readCurveSampleVec2Vf!( Float64 time, UInt32 curveCount, UInt32 pointToCurve<>, UInt32 optionalPointToIndex<>, io GeometryAttributes attributes ) {

  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicIVec2VfGeomParamSample sample = this._Vec2VfParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  Vec2 valuesA<> = sample.getValsVolatileData();

  UInt32 mapping<>;
  if( valuesA.size() >= attributes.size() )
    mapping = optionalPointToIndex;
  else if( valuesA.size() >= curveCount )
    mapping = pointToCurve;

  return this.readSampleVec2Vf( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleVec2Vf!(Float64 time, io PolygonMesh mesh, Boolean keepSameAttributeIndices) {

  if(this._info.time == time || this._numSamples == 0)
    return false;

  AlembicSampleInfo info(time, this._timeSampling, this._numSamples);
  if(info == this._info)
    return false;
  this._info = info;

  Vec2 valuesA<>;
  Vec2 valuesB<>;
  Ref<Vec2Attribute> attr = mesh.getOrCreateVec2Attribute(this._name);
  AlembicIVec2VfGeomParamSample sample = this._Vec2VfParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  valuesA = sample.getValsVolatileData();
  AlembicIVec2VfGeomParamSample sampleB = null;//Ensure its scope covers the values' lifetime

  if(this._info.requiresInterpolation()) {
    sampleB = this._Vec2VfParam.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getValsVolatileData();
  }

  if(this._scope == Alembic_kVertexScope || this._scope == Alembic_kVaryingScope) {

    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i].linearInterpolate(valuesB[i], Float32(this._info.fraction)));
    } else {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i]);
    }

  } else if(this._scope == Alembic_kFacevaryingScope || this._scope == Alembic_kUniformScope) {

    Size offset = 0;
    for(Size i=0;i<mesh.polygonCount();i++) {
      Size count = mesh.getPolygonSize(i);
      for(UInt32 j=0;j<count;j++) {
        Vec2 value = this._info.requiresInterpolation() ? valuesA[offset].linearInterpolate(valuesB[offset], Float32(this._info.fraction)) : valuesA[offset];
        if( keepSameAttributeIndices ) {
          UInt32 index = mesh.getPolygonAttributeIndex( i, count - 1 - j );
          attr.values[index] = value;
        } else
          mesh.setPolygonAttribute( i, count - 1 - j, attr, value );
        if( this._scope == Alembic_kFacevaryingScope ) { offset++; } // One value per corner of the polygon
      }
      if( this._scope == Alembic_kUniformScope ) { offset++; } // One value per polygon
    }
  }

  attr.incrementVersion();
  return true;
}

private AlembicGeometryParamReader.set!( AlembicIVec2VfGeomParam param ) {
  this._name = param.getName();
  if(this._name.startsWith('.'))
    this._name = this._name.leftStrip(1);
  this._paramType = "Vec2Vf";
  this._Vec2VfParam = param;
  this._timeSampling = this._Vec2VfParam.getTimeSampling();
  this._numSamples = this._Vec2VfParam.getNumSamples();
  this._scope = this._Vec2VfParam.getScope();
}

/// Constructor for AlembicIVec2VfGeomParam
public AlembicGeometryParamReader( AlembicArchiveReader archive, AlembicIVec2VfGeomParam param ) {
  this.archive = archive;
  this.set( param );
}

/// \internal
private AlembicGeometryParamWriter.initVec2Vf!(
  AlembicOCompoundProperty parent,
  String name,
  AlembicGeometryScope scope,
  SInt32 timeSampling,
  Ref<Vec2Attribute> attribute
)
{
  this._name = name;
  this._paramType = "Vec2Vf";
  this._scope = scope;
  this._Vec2VfParam = AlembicOVec2VfGeomParam(parent, name, false, scope, 1);
  this._Vec2VfParam.setTimeSampling(timeSampling);
  this._valueProperty = this._Vec2VfParam.getValueProperty();
}

/// \internal
private Boolean AlembicGeometryParamWriter.writeSampleVec2Vf!(
  Ref<Geometry> geometry,
  Ref<GeometryAttribute> attribute,
  UInt32 optionalPointToIndex<>
)
{
  Vec2Attribute castAttribute = attribute;
  if( castAttribute == null )
    throw 'AlembicGeometryParamWriter: Attribute "'+this._name+'",  type and paramType "'+this._paramType+'" not matching.';

  Vec2 values[] = castAttribute.values;
  if(this._scope == Alembic_kVertexScope)
  {
    if(geometry != null)
    {
      PolygonMesh mesh(geometry);
      if(mesh)
      {
        values = values.clone();
        values.resize(mesh.pointCount());
      }
    }
  }
  
  if( !optionalPointToIndex )
    this._Vec2VfParam.set( AlembicOVec2VfGeomParamSample( values, this._scope ) );
  else
  {
    Vec2 mappedValues[]; mappedValues.resize( optionalPointToIndex.size() );
    
    for( Index i=0; i<mappedValues.size(); i++ )
      mappedValues[i] = values[ optionalPointToIndex[i] ];

    this._Vec2VfParam.set( AlembicOVec2VfGeomParamSample( mappedValues, this._scope ) );
  }

  return true;
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleVec3Vf!(Float64 time, Vec3 valuesA<>, UInt32 optionalPointToIndex<>, io GeometryAttributes attributes) {

  Vec3Attribute attr = attributes.getOrCreateVec3Attribute(this._name);

  AlembicIVec3VfGeomParamSample sampleB = null;
  Vec3 valuesB<>;

  // If interpolation is required, but the topology changes, round to the nearest frame
  if( this._info.requiresInterpolation() ) {
    sampleB = this._Vec3VfParam.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getValsVolatileData();
    if( valuesA.size() != valuesB.size() )
      this._info.roundToClosestFrame();
  }

  Size sampleSize = valuesA.size();
  if( !optionalPointToIndex ) {
    Size count = Math_min( sampleSize, attr.size() );
    if( this._info.requiresInterpolation() ) {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i].linearInterpolate(valuesB[i], Float32(this._info.fraction));
    } else {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i];
    }
  } else {
    Size count = Math_min( optionalPointToIndex.size(), attr.size() );
    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index].linearInterpolate( valuesB[index], Float32( this._info.fraction ) );
      }
    } else {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index];
      }
    }
  }

  // if( !optionalPointToIndex && sampleSize != attr.size() ) {
  //   String name = this.getName();
  //   String originalName = this._Vec3VfParam.getName();
  //   if( name != originalName ) { name = "\"" + name + "\" (originally \"" + originalName +"\")"; }
  //   else { name = "\"" + name + "\""; }
  //   report( "AlembicGeometryParamReader.readSampleVec3Vf : Warning : reading the attribute " + name + " of size " + sampleSize
  //     + " in a GeometryAttribute of size " + attr.size() + " (" + ( sampleSize > attr.size() ? "truncating" : "padding") + " it). Archive : " + this.archive.getPath() );
  // }
  attr.incrementVersion();
  return true;
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleVec3Vf!( Float64 time, io GeometryAttributes attributes ) {
  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicIVec3VfGeomParamSample sample = this._Vec3VfParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  Vec3 valuesA<> = sample.getValsVolatileData();

  UInt32 mapping<>;
  return this.readSampleVec3Vf( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readCurveSampleVec3Vf!( Float64 time, UInt32 curveCount, UInt32 pointToCurve<>, UInt32 optionalPointToIndex<>, io GeometryAttributes attributes ) {

  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicIVec3VfGeomParamSample sample = this._Vec3VfParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  Vec3 valuesA<> = sample.getValsVolatileData();

  UInt32 mapping<>;
  if( valuesA.size() >= attributes.size() )
    mapping = optionalPointToIndex;
  else if( valuesA.size() >= curveCount )
    mapping = pointToCurve;

  return this.readSampleVec3Vf( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleVec3Vf!(Float64 time, io PolygonMesh mesh, Boolean keepSameAttributeIndices) {

  if(this._info.time == time || this._numSamples == 0)
    return false;

  AlembicSampleInfo info(time, this._timeSampling, this._numSamples);
  if(info == this._info)
    return false;
  this._info = info;

  Vec3 valuesA<>;
  Vec3 valuesB<>;
  Ref<Vec3Attribute> attr = mesh.getOrCreateVec3Attribute(this._name);
  AlembicIVec3VfGeomParamSample sample = this._Vec3VfParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  valuesA = sample.getValsVolatileData();
  AlembicIVec3VfGeomParamSample sampleB = null;//Ensure its scope covers the values' lifetime

  if(this._info.requiresInterpolation()) {
    sampleB = this._Vec3VfParam.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getValsVolatileData();
  }

  if(this._scope == Alembic_kVertexScope || this._scope == Alembic_kVaryingScope) {

    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i].linearInterpolate(valuesB[i], Float32(this._info.fraction)));
    } else {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i]);
    }

  } else if(this._scope == Alembic_kFacevaryingScope || this._scope == Alembic_kUniformScope) {

    Size offset = 0;
    for(Size i=0;i<mesh.polygonCount();i++) {
      Size count = mesh.getPolygonSize(i);
      for(UInt32 j=0;j<count;j++) {
        Vec3 value = this._info.requiresInterpolation() ? valuesA[offset].linearInterpolate(valuesB[offset], Float32(this._info.fraction)) : valuesA[offset];
        if( keepSameAttributeIndices ) {
          UInt32 index = mesh.getPolygonAttributeIndex( i, count - 1 - j );
          attr.values[index] = value;
        } else
          mesh.setPolygonAttribute( i, count - 1 - j, attr, value );
        if( this._scope == Alembic_kFacevaryingScope ) { offset++; } // One value per corner of the polygon
      }
      if( this._scope == Alembic_kUniformScope ) { offset++; } // One value per polygon
    }
  }

  attr.incrementVersion();
  return true;
}

private AlembicGeometryParamReader.set!( AlembicIVec3VfGeomParam param ) {
  this._name = param.getName();
  if(this._name.startsWith('.'))
    this._name = this._name.leftStrip(1);
  this._paramType = "Vec3Vf";
  this._Vec3VfParam = param;
  this._timeSampling = this._Vec3VfParam.getTimeSampling();
  this._numSamples = this._Vec3VfParam.getNumSamples();
  this._scope = this._Vec3VfParam.getScope();
}

/// Constructor for AlembicIVec3VfGeomParam
public AlembicGeometryParamReader( AlembicArchiveReader archive, AlembicIVec3VfGeomParam param ) {
  this.archive = archive;
  this.set( param );
}

/// \internal
private AlembicGeometryParamWriter.initVec3Vf!(
  AlembicOCompoundProperty parent,
  String name,
  AlembicGeometryScope scope,
  SInt32 timeSampling,
  Ref<Vec3Attribute> attribute
)
{
  this._name = name;
  this._paramType = "Vec3Vf";
  this._scope = scope;
  this._Vec3VfParam = AlembicOVec3VfGeomParam(parent, name, false, scope, 1);
  this._Vec3VfParam.setTimeSampling(timeSampling);
  this._valueProperty = this._Vec3VfParam.getValueProperty();
}

/// \internal
private Boolean AlembicGeometryParamWriter.writeSampleVec3Vf!(
  Ref<Geometry> geometry,
  Ref<GeometryAttribute> attribute,
  UInt32 optionalPointToIndex<>
)
{
  Vec3Attribute castAttribute = attribute;
  if( castAttribute == null )
    throw 'AlembicGeometryParamWriter: Attribute "'+this._name+'",  type and paramType "'+this._paramType+'" not matching.';

  Vec3 values[] = castAttribute.values;
  if(this._scope == Alembic_kVertexScope)
  {
    if(geometry != null)
    {
      PolygonMesh mesh(geometry);
      if(mesh)
      {
        values = values.clone();
        values.resize(mesh.pointCount());
      }
    }
  }
  
  if( !optionalPointToIndex )
    this._Vec3VfParam.set( AlembicOVec3VfGeomParamSample( values, this._scope ) );
  else
  {
    Vec3 mappedValues[]; mappedValues.resize( optionalPointToIndex.size() );
    
    for( Index i=0; i<mappedValues.size(); i++ )
      mappedValues[i] = values[ optionalPointToIndex[i] ];

    this._Vec3VfParam.set( AlembicOVec3VfGeomParamSample( mappedValues, this._scope ) );
  }

  return true;
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleVec3Nf!(Float64 time, Vec3 valuesA<>, UInt32 optionalPointToIndex<>, io GeometryAttributes attributes) {

  Vec3Attribute attr = attributes.getOrCreateVec3Attribute(this._name);

  AlembicIVec3NfGeomParamSample sampleB = null;
  Vec3 valuesB<>;

  // If interpolation is required, but the topology changes, round to the nearest frame
  if( this._info.requiresInterpolation() ) {
    sampleB = this._Vec3NfParam.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getValsVolatileData();
    if( valuesA.size() != valuesB.size() )
      this._info.roundToClosestFrame();
  }

  Size sampleSize = valuesA.size();
  if( !optionalPointToIndex ) {
    Size count = Math_min( sampleSize, attr.size() );
    if( this._info.requiresInterpolation() ) {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i].linearInterpolate(valuesB[i], Float32(this._info.fraction));
    } else {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i];
    }
  } else {
    Size count = Math_min( optionalPointToIndex.size(), attr.size() );
    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index].linearInterpolate( valuesB[index], Float32( this._info.fraction ) );
      }
    } else {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index];
      }
    }
  }

  // if( !optionalPointToIndex && sampleSize != attr.size() ) {
  //   String name = this.getName();
  //   String originalName = this._Vec3NfParam.getName();
  //   if( name != originalName ) { name = "\"" + name + "\" (originally \"" + originalName +"\")"; }
  //   else { name = "\"" + name + "\""; }
  //   report( "AlembicGeometryParamReader.readSampleVec3Nf : Warning : reading the attribute " + name + " of size " + sampleSize
  //     + " in a GeometryAttribute of size " + attr.size() + " (" + ( sampleSize > attr.size() ? "truncating" : "padding") + " it). Archive : " + this.archive.getPath() );
  // }
  attr.incrementVersion();
  return true;
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleVec3Nf!( Float64 time, io GeometryAttributes attributes ) {
  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicIVec3NfGeomParamSample sample = this._Vec3NfParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  Vec3 valuesA<> = sample.getValsVolatileData();

  UInt32 mapping<>;
  return this.readSampleVec3Nf( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readCurveSampleVec3Nf!( Float64 time, UInt32 curveCount, UInt32 pointToCurve<>, UInt32 optionalPointToIndex<>, io GeometryAttributes attributes ) {

  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicIVec3NfGeomParamSample sample = this._Vec3NfParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  Vec3 valuesA<> = sample.getValsVolatileData();

  UInt32 mapping<>;
  if( valuesA.size() >= attributes.size() )
    mapping = optionalPointToIndex;
  else if( valuesA.size() >= curveCount )
    mapping = pointToCurve;

  return this.readSampleVec3Nf( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleVec3Nf!(Float64 time, io PolygonMesh mesh, Boolean keepSameAttributeIndices) {

  if(this._info.time == time || this._numSamples == 0)
    return false;

  AlembicSampleInfo info(time, this._timeSampling, this._numSamples);
  if(info == this._info)
    return false;
  this._info = info;

  Vec3 valuesA<>;
  Vec3 valuesB<>;
  Ref<Vec3Attribute> attr = mesh.getOrCreateVec3Attribute(this._name);
  AlembicIVec3NfGeomParamSample sample = this._Vec3NfParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  valuesA = sample.getValsVolatileData();
  AlembicIVec3NfGeomParamSample sampleB = null;//Ensure its scope covers the values' lifetime

  if(this._info.requiresInterpolation()) {
    sampleB = this._Vec3NfParam.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getValsVolatileData();
  }

  if(this._scope == Alembic_kVertexScope || this._scope == Alembic_kVaryingScope) {

    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i].linearInterpolate(valuesB[i], Float32(this._info.fraction)));
    } else {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i]);
    }

  } else if(this._scope == Alembic_kFacevaryingScope || this._scope == Alembic_kUniformScope) {

    Size offset = 0;
    for(Size i=0;i<mesh.polygonCount();i++) {
      Size count = mesh.getPolygonSize(i);
      for(UInt32 j=0;j<count;j++) {
        Vec3 value = this._info.requiresInterpolation() ? valuesA[offset].linearInterpolate(valuesB[offset], Float32(this._info.fraction)) : valuesA[offset];
        if( keepSameAttributeIndices ) {
          UInt32 index = mesh.getPolygonAttributeIndex( i, count - 1 - j );
          attr.values[index] = value;
        } else
          mesh.setPolygonAttribute( i, count - 1 - j, attr, value );
        if( this._scope == Alembic_kFacevaryingScope ) { offset++; } // One value per corner of the polygon
      }
      if( this._scope == Alembic_kUniformScope ) { offset++; } // One value per polygon
    }
  }

  attr.incrementVersion();
  return true;
}

private AlembicGeometryParamReader.set!( AlembicIVec3NfGeomParam param ) {
  this._name = param.getName();
  if(this._name.startsWith('.'))
    this._name = this._name.leftStrip(1);
  this._paramType = "Vec3Nf";
  this._Vec3NfParam = param;
  this._timeSampling = this._Vec3NfParam.getTimeSampling();
  this._numSamples = this._Vec3NfParam.getNumSamples();
  this._scope = this._Vec3NfParam.getScope();
}

/// Constructor for AlembicIVec3NfGeomParam
public AlembicGeometryParamReader( AlembicArchiveReader archive, AlembicIVec3NfGeomParam param ) {
  this.archive = archive;
  this.set( param );
}

/// \internal
private AlembicGeometryParamWriter.initVec3Nf!(
  AlembicOCompoundProperty parent,
  String name,
  AlembicGeometryScope scope,
  SInt32 timeSampling,
  Ref<Vec3Attribute> attribute
)
{
  this._name = name;
  this._paramType = "Vec3Nf";
  this._scope = scope;
  this._Vec3NfParam = AlembicOVec3NfGeomParam(parent, name, false, scope, 1);
  this._Vec3NfParam.setTimeSampling(timeSampling);
  this._valueProperty = this._Vec3NfParam.getValueProperty();
}

/// \internal
private Boolean AlembicGeometryParamWriter.writeSampleVec3Nf!(
  Ref<Geometry> geometry,
  Ref<GeometryAttribute> attribute,
  UInt32 optionalPointToIndex<>
)
{
  Vec3Attribute castAttribute = attribute;
  if( castAttribute == null )
    throw 'AlembicGeometryParamWriter: Attribute "'+this._name+'",  type and paramType "'+this._paramType+'" not matching.';

  Vec3 values[] = castAttribute.values;
  if(this._scope == Alembic_kVertexScope)
  {
    if(geometry != null)
    {
      PolygonMesh mesh(geometry);
      if(mesh)
      {
        values = values.clone();
        values.resize(mesh.pointCount());
      }
    }
  }
  
  if( !optionalPointToIndex )
    this._Vec3NfParam.set( AlembicOVec3NfGeomParamSample( values, this._scope ) );
  else
  {
    Vec3 mappedValues[]; mappedValues.resize( optionalPointToIndex.size() );
    
    for( Index i=0; i<mappedValues.size(); i++ )
      mappedValues[i] = values[ optionalPointToIndex[i] ];

    this._Vec3NfParam.set( AlembicOVec3NfGeomParamSample( mappedValues, this._scope ) );
  }

  return true;
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleQuatf!(Float64 time, Quat valuesA[], UInt32 optionalPointToIndex<>, io GeometryAttributes attributes) {

  QuatAttribute attr = attributes.getOrCreateQuatAttribute(this._name);

  AlembicIQuatfGeomParamSample sampleB = null;
  Quat valuesB[];

  // If interpolation is required, but the topology changes, round to the nearest frame
  if( this._info.requiresInterpolation() ) {
    sampleB = this._QuatfParam.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getVals();
    if( valuesA.size() != valuesB.size() )
      this._info.roundToClosestFrame();
  }

  Size sampleSize = valuesA.size();
  if( !optionalPointToIndex ) {
    Size count = Math_min( sampleSize, attr.size() );
    if( this._info.requiresInterpolation() ) {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i].sphericalLinearInterpolate(valuesB[i], Float32(this._info.fraction));
    } else {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i];
    }
  } else {
    Size count = Math_min( optionalPointToIndex.size(), attr.size() );
    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index].sphericalLinearInterpolate( valuesB[index], Float32( this._info.fraction ) );
      }
    } else {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index];
      }
    }
  }

  // if( !optionalPointToIndex && sampleSize != attr.size() ) {
  //   String name = this.getName();
  //   String originalName = this._QuatfParam.getName();
  //   if( name != originalName ) { name = "\"" + name + "\" (originally \"" + originalName +"\")"; }
  //   else { name = "\"" + name + "\""; }
  //   report( "AlembicGeometryParamReader.readSampleQuatf : Warning : reading the attribute " + name + " of size " + sampleSize
  //     + " in a GeometryAttribute of size " + attr.size() + " (" + ( sampleSize > attr.size() ? "truncating" : "padding") + " it). Archive : " + this.archive.getPath() );
  // }
  attr.incrementVersion();
  return true;
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleQuatf!( Float64 time, io GeometryAttributes attributes ) {
  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicIQuatfGeomParamSample sample = this._QuatfParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  Quat valuesA[] = sample.getVals();

  UInt32 mapping<>;
  return this.readSampleQuatf( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readCurveSampleQuatf!( Float64 time, UInt32 curveCount, UInt32 pointToCurve<>, UInt32 optionalPointToIndex<>, io GeometryAttributes attributes ) {

  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicIQuatfGeomParamSample sample = this._QuatfParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  Quat valuesA[] = sample.getVals();

  UInt32 mapping<>;
  if( valuesA.size() >= attributes.size() )
    mapping = optionalPointToIndex;
  else if( valuesA.size() >= curveCount )
    mapping = pointToCurve;

  return this.readSampleQuatf( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleQuatf!(Float64 time, io PolygonMesh mesh, Boolean keepSameAttributeIndices) {

  if(this._info.time == time || this._numSamples == 0)
    return false;

  AlembicSampleInfo info(time, this._timeSampling, this._numSamples);
  if(info == this._info)
    return false;
  this._info = info;

  Quat valuesA[];
  Quat valuesB[];
  Ref<QuatAttribute> attr = mesh.getOrCreateQuatAttribute(this._name);
  AlembicIQuatfGeomParamSample sample = this._QuatfParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  valuesA = sample.getVals();
  AlembicIQuatfGeomParamSample sampleB = null;//Ensure its scope covers the values' lifetime

  if(this._info.requiresInterpolation()) {
    sampleB = this._QuatfParam.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getVals();
  }

  if(this._scope == Alembic_kVertexScope || this._scope == Alembic_kVaryingScope) {

    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i].sphericalLinearInterpolate(valuesB[i], Float32(this._info.fraction)));
    } else {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i]);
    }

  } else if(this._scope == Alembic_kFacevaryingScope || this._scope == Alembic_kUniformScope) {

    Size offset = 0;
    for(Size i=0;i<mesh.polygonCount();i++) {
      Size count = mesh.getPolygonSize(i);
      for(UInt32 j=0;j<count;j++) {
        Quat value = this._info.requiresInterpolation() ? valuesA[offset].sphericalLinearInterpolate(valuesB[offset], Float32(this._info.fraction)) : valuesA[offset];
        if( keepSameAttributeIndices ) {
          UInt32 index = mesh.getPolygonAttributeIndex( i, count - 1 - j );
          attr.values[index] = value;
        } else
          mesh.setPolygonAttribute( i, count - 1 - j, attr, value );
        if( this._scope == Alembic_kFacevaryingScope ) { offset++; } // One value per corner of the polygon
      }
      if( this._scope == Alembic_kUniformScope ) { offset++; } // One value per polygon
    }
  }

  attr.incrementVersion();
  return true;
}

private AlembicGeometryParamReader.set!( AlembicIQuatfGeomParam param ) {
  this._name = param.getName();
  if(this._name.startsWith('.'))
    this._name = this._name.leftStrip(1);
  this._paramType = "Quatf";
  this._QuatfParam = param;
  this._timeSampling = this._QuatfParam.getTimeSampling();
  this._numSamples = this._QuatfParam.getNumSamples();
  this._scope = this._QuatfParam.getScope();
}

/// Constructor for AlembicIQuatfGeomParam
public AlembicGeometryParamReader( AlembicArchiveReader archive, AlembicIQuatfGeomParam param ) {
  this.archive = archive;
  this.set( param );
}

/// \internal
private AlembicGeometryParamWriter.initQuatf!(
  AlembicOCompoundProperty parent,
  String name,
  AlembicGeometryScope scope,
  SInt32 timeSampling,
  Ref<QuatAttribute> attribute
)
{
  this._name = name;
  this._paramType = "Quatf";
  this._scope = scope;
  this._QuatfParam = AlembicOQuatfGeomParam(parent, name, false, scope, 1);
  this._QuatfParam.setTimeSampling(timeSampling);
  this._valueProperty = this._QuatfParam.getValueProperty();
}

/// \internal
private Boolean AlembicGeometryParamWriter.writeSampleQuatf!(
  Ref<Geometry> geometry,
  Ref<GeometryAttribute> attribute,
  UInt32 optionalPointToIndex<>
)
{
  QuatAttribute castAttribute = attribute;
  if( castAttribute == null )
    throw 'AlembicGeometryParamWriter: Attribute "'+this._name+'",  type and paramType "'+this._paramType+'" not matching.';

  Quat values[] = castAttribute.values;
  if(this._scope == Alembic_kVertexScope)
  {
    if(geometry != null)
    {
      PolygonMesh mesh(geometry);
      if(mesh)
      {
        values = values.clone();
        values.resize(mesh.pointCount());
      }
    }
  }
  
  if( !optionalPointToIndex )
    this._QuatfParam.set( AlembicOQuatfGeomParamSample( values, this._scope ) );
  else
  {
    Quat mappedValues[]; mappedValues.resize( optionalPointToIndex.size() );
    
    for( Index i=0; i<mappedValues.size(); i++ )
      mappedValues[i] = values[ optionalPointToIndex[i] ];

    this._QuatfParam.set( AlembicOQuatfGeomParamSample( mappedValues, this._scope ) );
  }

  return true;
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleColorf!(Float64 time, Color valuesA<>, UInt32 optionalPointToIndex<>, io GeometryAttributes attributes) {

  ColorAttribute attr = attributes.getOrCreateColorAttribute(this._name);

  AlembicIColorfGeomParamSample sampleB = null;
  Color valuesB<>;

  // If interpolation is required, but the topology changes, round to the nearest frame
  if( this._info.requiresInterpolation() ) {
    sampleB = this._ColorfParam.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getValsVolatileData();
    if( valuesA.size() != valuesB.size() )
      this._info.roundToClosestFrame();
  }

  Size sampleSize = valuesA.size();
  if( !optionalPointToIndex ) {
    Size count = Math_min( sampleSize, attr.size() );
    if( this._info.requiresInterpolation() ) {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i].linearInterpolate(valuesB[i], Float32(this._info.fraction));
    } else {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i];
    }
  } else {
    Size count = Math_min( optionalPointToIndex.size(), attr.size() );
    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index].linearInterpolate( valuesB[index], Float32( this._info.fraction ) );
      }
    } else {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index];
      }
    }
  }

  // if( !optionalPointToIndex && sampleSize != attr.size() ) {
  //   String name = this.getName();
  //   String originalName = this._ColorfParam.getName();
  //   if( name != originalName ) { name = "\"" + name + "\" (originally \"" + originalName +"\")"; }
  //   else { name = "\"" + name + "\""; }
  //   report( "AlembicGeometryParamReader.readSampleColorf : Warning : reading the attribute " + name + " of size " + sampleSize
  //     + " in a GeometryAttribute of size " + attr.size() + " (" + ( sampleSize > attr.size() ? "truncating" : "padding") + " it). Archive : " + this.archive.getPath() );
  // }
  attr.incrementVersion();
  return true;
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleColorf!( Float64 time, io GeometryAttributes attributes ) {
  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicIColorfGeomParamSample sample = this._ColorfParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  Color valuesA<> = sample.getValsVolatileData();

  UInt32 mapping<>;
  return this.readSampleColorf( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readCurveSampleColorf!( Float64 time, UInt32 curveCount, UInt32 pointToCurve<>, UInt32 optionalPointToIndex<>, io GeometryAttributes attributes ) {

  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicIColorfGeomParamSample sample = this._ColorfParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  Color valuesA<> = sample.getValsVolatileData();

  UInt32 mapping<>;
  if( valuesA.size() >= attributes.size() )
    mapping = optionalPointToIndex;
  else if( valuesA.size() >= curveCount )
    mapping = pointToCurve;

  return this.readSampleColorf( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleColorf!(Float64 time, io PolygonMesh mesh, Boolean keepSameAttributeIndices) {

  if(this._info.time == time || this._numSamples == 0)
    return false;

  AlembicSampleInfo info(time, this._timeSampling, this._numSamples);
  if(info == this._info)
    return false;
  this._info = info;

  Color valuesA<>;
  Color valuesB<>;
  Ref<ColorAttribute> attr = mesh.getOrCreateColorAttribute(this._name);
  AlembicIColorfGeomParamSample sample = this._ColorfParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  valuesA = sample.getValsVolatileData();
  AlembicIColorfGeomParamSample sampleB = null;//Ensure its scope covers the values' lifetime

  if(this._info.requiresInterpolation()) {
    sampleB = this._ColorfParam.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getValsVolatileData();
  }

  if(this._scope == Alembic_kVertexScope || this._scope == Alembic_kVaryingScope) {

    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i].linearInterpolate(valuesB[i], Float32(this._info.fraction)));
    } else {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i]);
    }

  } else if(this._scope == Alembic_kFacevaryingScope || this._scope == Alembic_kUniformScope) {

    Size offset = 0;
    for(Size i=0;i<mesh.polygonCount();i++) {
      Size count = mesh.getPolygonSize(i);
      for(UInt32 j=0;j<count;j++) {
        Color value = this._info.requiresInterpolation() ? valuesA[offset].linearInterpolate(valuesB[offset], Float32(this._info.fraction)) : valuesA[offset];
        if( keepSameAttributeIndices ) {
          UInt32 index = mesh.getPolygonAttributeIndex( i, count - 1 - j );
          attr.values[index] = value;
        } else
          mesh.setPolygonAttribute( i, count - 1 - j, attr, value );
        if( this._scope == Alembic_kFacevaryingScope ) { offset++; } // One value per corner of the polygon
      }
      if( this._scope == Alembic_kUniformScope ) { offset++; } // One value per polygon
    }
  }

  attr.incrementVersion();
  return true;
}

private AlembicGeometryParamReader.set!( AlembicIColorfGeomParam param ) {
  this._name = param.getName();
  if(this._name.startsWith('.'))
    this._name = this._name.leftStrip(1);
  this._paramType = "Colorf";
  this._ColorfParam = param;
  this._timeSampling = this._ColorfParam.getTimeSampling();
  this._numSamples = this._ColorfParam.getNumSamples();
  this._scope = this._ColorfParam.getScope();
}

/// Constructor for AlembicIColorfGeomParam
public AlembicGeometryParamReader( AlembicArchiveReader archive, AlembicIColorfGeomParam param ) {
  this.archive = archive;
  this.set( param );
}

/// \internal
private AlembicGeometryParamWriter.initColorf!(
  AlembicOCompoundProperty parent,
  String name,
  AlembicGeometryScope scope,
  SInt32 timeSampling,
  Ref<ColorAttribute> attribute
)
{
  this._name = name;
  this._paramType = "Colorf";
  this._scope = scope;
  this._ColorfParam = AlembicOColorfGeomParam(parent, name, false, scope, 1);
  this._ColorfParam.setTimeSampling(timeSampling);
  this._valueProperty = this._ColorfParam.getValueProperty();
}

/// \internal
private Boolean AlembicGeometryParamWriter.writeSampleColorf!(
  Ref<Geometry> geometry,
  Ref<GeometryAttribute> attribute,
  UInt32 optionalPointToIndex<>
)
{
  ColorAttribute castAttribute = attribute;
  if( castAttribute == null )
    throw 'AlembicGeometryParamWriter: Attribute "'+this._name+'",  type and paramType "'+this._paramType+'" not matching.';

  Color values[] = castAttribute.values;
  if(this._scope == Alembic_kVertexScope)
  {
    if(geometry != null)
    {
      PolygonMesh mesh(geometry);
      if(mesh)
      {
        values = values.clone();
        values.resize(mesh.pointCount());
      }
    }
  }
  
  if( !optionalPointToIndex )
    this._ColorfParam.set( AlembicOColorfGeomParamSample( values, this._scope ) );
  else
  {
    Color mappedValues[]; mappedValues.resize( optionalPointToIndex.size() );
    
    for( Index i=0; i<mappedValues.size(); i++ )
      mappedValues[i] = values[ optionalPointToIndex[i] ];

    this._ColorfParam.set( AlembicOColorfGeomParamSample( mappedValues, this._scope ) );
  }

  return true;
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleMat44f!(Float64 time, Mat44 valuesA<>, UInt32 optionalPointToIndex<>, io GeometryAttributes attributes) {

  Mat44Attribute attr = attributes.getOrCreateMat44Attribute(this._name);

  AlembicIMat44fGeomParamSample sampleB = null;
  Mat44 valuesB<>;

  // If interpolation is required, but the topology changes, round to the nearest frame
  if( this._info.requiresInterpolation() ) {
    sampleB = this._Mat44fParam.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getValsVolatileData();
    if( valuesA.size() != valuesB.size() )
      this._info.roundToClosestFrame();
  }

  Size sampleSize = valuesA.size();
  if( !optionalPointToIndex ) {
    Size count = Math_min( sampleSize, attr.size() );
    if( this._info.requiresInterpolation() ) {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i].interpolate(valuesB[i], Float32(this._info.fraction));
    } else {
      for(Size i=0;i<count;i++)
        attr.values[i] = valuesA[i];
    }
  } else {
    Size count = Math_min( optionalPointToIndex.size(), attr.size() );
    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index].interpolate( valuesB[index], Float32( this._info.fraction ) );
      }
    } else {
      for(Size i=0;i<count;i++) {
        UInt32 index = optionalPointToIndex[i];
        if( index < sampleSize )
          attr.values[i] = valuesA[index];
      }
    }
  }

  // if( !optionalPointToIndex && sampleSize != attr.size() ) {
  //   String name = this.getName();
  //   String originalName = this._Mat44fParam.getName();
  //   if( name != originalName ) { name = "\"" + name + "\" (originally \"" + originalName +"\")"; }
  //   else { name = "\"" + name + "\""; }
  //   report( "AlembicGeometryParamReader.readSampleMat44f : Warning : reading the attribute " + name + " of size " + sampleSize
  //     + " in a GeometryAttribute of size " + attr.size() + " (" + ( sampleSize > attr.size() ? "truncating" : "padding") + " it). Archive : " + this.archive.getPath() );
  // }
  attr.incrementVersion();
  return true;
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleMat44f!( Float64 time, io GeometryAttributes attributes ) {
  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicIMat44fGeomParamSample sample = this._Mat44fParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  Mat44 valuesA<> = sample.getValsVolatileData();

  UInt32 mapping<>;
  return this.readSampleMat44f( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readCurveSampleMat44f!( Float64 time, UInt32 curveCount, UInt32 pointToCurve<>, UInt32 optionalPointToIndex<>, io GeometryAttributes attributes ) {

  if( this._info.time == time || this._numSamples == 0 )
    return false;

  AlembicSampleInfo info( time, this._timeSampling, this._numSamples );
  if( info == this._info )
    return false;
  this._info = info;

  AlembicIMat44fGeomParamSample sample = this._Mat44fParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  Mat44 valuesA<> = sample.getValsVolatileData();

  UInt32 mapping<>;
  if( valuesA.size() >= attributes.size() )
    mapping = optionalPointToIndex;
  else if( valuesA.size() >= curveCount )
    mapping = pointToCurve;

  return this.readSampleMat44f( time, valuesA, mapping, attributes );
}

/// \internal
Boolean AlembicGeometryParamReader.readSampleMat44f!(Float64 time, io PolygonMesh mesh, Boolean keepSameAttributeIndices) {

  if(this._info.time == time || this._numSamples == 0)
    return false;

  AlembicSampleInfo info(time, this._timeSampling, this._numSamples);
  if(info == this._info)
    return false;
  this._info = info;

  Mat44 valuesA<>;
  Mat44 valuesB<>;
  Ref<Mat44Attribute> attr = mesh.getOrCreateMat44Attribute(this._name);
  AlembicIMat44fGeomParamSample sample = this._Mat44fParam.getExpanded( this.archive.getISampleSelector( this._info.indexA ) );
  valuesA = sample.getValsVolatileData();
  AlembicIMat44fGeomParamSample sampleB = null;//Ensure its scope covers the values' lifetime

  if(this._info.requiresInterpolation()) {
    sampleB = this._Mat44fParam.getExpanded( this.archive.getISampleSelector( this._info.indexB ) );
    valuesB = sampleB.getValsVolatileData();
  }

  if(this._scope == Alembic_kVertexScope || this._scope == Alembic_kVaryingScope) {

    if(this._info.requiresInterpolation()) {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i].interpolate(valuesB[i], Float32(this._info.fraction)));
    } else {
      for(Size i=0;i<mesh.pointCount();i++)
        mesh.setPointAttribute(i, attr, valuesA[i]);
    }

  } else if(this._scope == Alembic_kFacevaryingScope || this._scope == Alembic_kUniformScope) {

    Size offset = 0;
    for(Size i=0;i<mesh.polygonCount();i++) {
      Size count = mesh.getPolygonSize(i);
      for(UInt32 j=0;j<count;j++) {
        Mat44 value = this._info.requiresInterpolation() ? valuesA[offset].interpolate(valuesB[offset], Float32(this._info.fraction)) : valuesA[offset];
        if( keepSameAttributeIndices ) {
          UInt32 index = mesh.getPolygonAttributeIndex( i, count - 1 - j );
          attr.values[index] = value;
        } else
          mesh.setPolygonAttribute( i, count - 1 - j, attr, value );
        if( this._scope == Alembic_kFacevaryingScope ) { offset++; } // One value per corner of the polygon
      }
      if( this._scope == Alembic_kUniformScope ) { offset++; } // One value per polygon
    }
  }

  attr.incrementVersion();
  return true;
}

private AlembicGeometryParamReader.set!( AlembicIMat44fGeomParam param ) {
  this._name = param.getName();
  if(this._name.startsWith('.'))
    this._name = this._name.leftStrip(1);
  this._paramType = "Mat44f";
  this._Mat44fParam = param;
  this._timeSampling = this._Mat44fParam.getTimeSampling();
  this._numSamples = this._Mat44fParam.getNumSamples();
  this._scope = this._Mat44fParam.getScope();
}

/// Constructor for AlembicIMat44fGeomParam
public AlembicGeometryParamReader( AlembicArchiveReader archive, AlembicIMat44fGeomParam param ) {
  this.archive = archive;
  this.set( param );
}

/// \internal
private AlembicGeometryParamWriter.initMat44f!(
  AlembicOCompoundProperty parent,
  String name,
  AlembicGeometryScope scope,
  SInt32 timeSampling,
  Ref<Mat44Attribute> attribute
)
{
  this._name = name;
  this._paramType = "Mat44f";
  this._scope = scope;
  this._Mat44fParam = AlembicOMat44fGeomParam(parent, name, false, scope, 1);
  this._Mat44fParam.setTimeSampling(timeSampling);
  this._valueProperty = this._Mat44fParam.getValueProperty();
}

/// \internal
private Boolean AlembicGeometryParamWriter.writeSampleMat44f!(
  Ref<Geometry> geometry,
  Ref<GeometryAttribute> attribute,
  UInt32 optionalPointToIndex<>
)
{
  Mat44Attribute castAttribute = attribute;
  if( castAttribute == null )
    throw 'AlembicGeometryParamWriter: Attribute "'+this._name+'",  type and paramType "'+this._paramType+'" not matching.';

  Mat44 values[] = castAttribute.values;
  if(this._scope == Alembic_kVertexScope)
  {
    if(geometry != null)
    {
      PolygonMesh mesh(geometry);
      if(mesh)
      {
        values = values.clone();
        values.resize(mesh.pointCount());
      }
    }
  }
  
  if( !optionalPointToIndex )
    this._Mat44fParam.set( AlembicOMat44fGeomParamSample( values, this._scope ) );
  else
  {
    Mat44 mappedValues[]; mappedValues.resize( optionalPointToIndex.size() );
    
    for( Index i=0; i<mappedValues.size(); i++ )
      mappedValues[i] = values[ optionalPointToIndex[i] ];

    this._Mat44fParam.set( AlembicOMat44fGeomParamSample( mappedValues, this._scope ) );
  }

  return true;
}