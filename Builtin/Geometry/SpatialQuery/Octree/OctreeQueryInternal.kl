//
// Copyright (c) 2010-2017 Fabric Software Inc. All rights reserved.
//

/// \internal
struct OctreeQueryCellAndCenter {
  Vec3 cellCenter;
  UInt32 cellIndex;
};

/// \internal
struct OctreeQueryTraverseData {
  Size currentSet;
  Size currentSetSize;
  Size nextSet;
  Size nextSetSize;
  OctreeQueryCellAndCenter data[2][];
};

inline OctreeQueryTraverseData(){
  this.reset();
}

inline OctreeQueryTraverseData.reset!() {
  this.currentSet = 0;
  this.currentSetSize = 0;
  this.nextSet = 1;
  this.nextSetSize = 0;
}

inline OctreeQueryTraverseData.pushToNext!( UInt32 cellIndex, Vec3 cellCenter, io OctreeQueryCellAndCenter data[] ) {
  if( data.size() == this.nextSetSize )
    data.resize( this.nextSetSize+1 );
  OctreeQueryCellAndCenter cellData;
  cellData.cellIndex = cellIndex;
  cellData.cellCenter = cellCenter;
  data[this.nextSetSize++] = cellData;
}

inline OctreeQueryTraverseData.pushToNext!( UInt32 cellIndex, Vec3 center ) {
  this.pushToNext( cellIndex, center, this.data[this.nextSet] );
}

inline Size OctreeQueryTraverseData.size() {
  return this.currentSetSize;
}

inline OctreeQueryTraverseData.get( Size index, io UInt32 cellIndex, io Vec3 center ) {
  OctreeQueryCellAndCenter cellData = this.data[this.currentSet][index];
  cellIndex = cellData.cellIndex;
  center = cellData.cellCenter;
}

inline OctreeQueryTraverseData.swap!() {
  this.currentSet = this.nextSet;
  this.nextSet = (this.nextSet + 1)&1;
  this.currentSetSize = this.nextSetSize;
  this.nextSetSize = 0;
}

function OctCellBBox OctreeStruct.getOctBBoxAndMaxSearchDepth?( Vec3 min, Vec3 max, io UInt8 maxSearchDepth ) {
  OctCellBBox octBBox;
  this.getOctBBox( min, max, true, octBBox );

  UInt16 bboxSize[3];
  bboxSize[0] = octBBox.max.xyz[0] - octBBox.min.xyz[0];
  bboxSize[1] = octBBox.max.xyz[1] - octBBox.min.xyz[1];
  bboxSize[2] = octBBox.max.xyz[2] - octBBox.min.xyz[2];

  UInt8 depthSize[3];
  depthSize[0] = getDepthSize( bboxSize[0] );
  depthSize[1] = getDepthSize( bboxSize[1] );
  depthSize[2] = getDepthSize( bboxSize[2] );

  UInt8 minDepthSize = depthSize[0];
  if( minDepthSize < depthSize[1] )
    minDepthSize = depthSize[1];
  if( minDepthSize < depthSize[2] )
    minDepthSize = depthSize[2];

  maxSearchDepth = minDepthSize + 2;
  return octBBox;
}

//NOTE: this is conservative, can return more objects than the 'exact' result
function OctreeStruct.localBBoxQuery?( Vec3 min, Vec3 max, io OctreeQueryTraverseData tempTraverseData, io IndexSet result, BitVector objectMask ) {
  result.clear();
  tempTraverseData.reset();
  Boolean noMask = objectMask.size() == 0;

  //First add infinite results
  Size nbInfinite = 0;
  UInt32 infiniteObjectIndex;
  OctreeArrayIterator it = this.packedMemberLists.getIterator( this.getInfiniteBVolList() );
  while( this.packedMemberLists.getNext( it, infiniteObjectIndex ) ) {
    if(noMask || objectMask.get(infiniteObjectIndex)) {
      ++nbInfinite;
      result.add( infiniteObjectIndex );
    }
  }

  UInt8 maxSearchDepth;
  OctCellBBox octBBox = this.getOctBBoxAndMaxSearchDepth( min, max, maxSearchDepth );

  tempTraverseData.pushToNext( this.rootCellIndex, Vec3() );
  tempTraverseData.swap();

  UInt8 currDepth = 0;
  UInt64 currCellVolume = this.packedCellData[this.rootCellIndex].octBBox.getVolume();

  while( tempTraverseData.size() != 0 && currDepth <= maxSearchDepth ) {
    Size numCells = tempTraverseData.size();
    for( Size i = 0; i < numCells; ++i ) {
      Vec3 cellCenter;
      Size cellIndex;
      tempTraverseData.get( i, cellIndex, cellCenter );
      UInt8 intersectionType = octBBox.getIntersectionType( this.packedCellData[cellIndex].octBBox );
      if( intersectionType == IntersectionNone )
        continue;
      else {

        Boolean allCellObjects = !this.packedCellData[cellIndex].isSubdivided() || intersectionType == IntersectionIncludesOther || currDepth == maxSearchDepth;
        if( !allCellObjects ) {
          //Depending on the overlap amount, we might decide to get all objects
          OctCellBBox intersectionBBox = getBBoxIntersection( octBBox, this.packedCellData[cellIndex].octBBox );
          UInt64 intersectionVolume = intersectionBBox.getVolume();
          if( intersectionVolume*2 > currCellVolume )
            allCellObjects = true;
        }

        this.addCellObjects( this.packedCellData[cellIndex], objectMask, result, allCellObjects );
        if( !allCellObjects ) {
          Boolean keep;
          if( this.keepSubCellObjectList ) {
            //First, ensure that there are potential objects that can be discarded by going deeper
            UInt32 objectIndex;
            it = this.packedMemberLists.getIterator( this.packedCellData[cellIndex].arrays[OctreeCellArray_subCellObjects] );
            while( this.packedMemberLists.getNext( it, objectIndex ) ) {
              if( (noMask || objectMask.get(objectIndex) ) && !result.has(objectIndex) ) {
                keep = true;
                break;
              }
            }
          } else
            keep = true;

          if(keep) {
            //Partial: push only intersected subcells
            OctCellPath centerPath = this.packedCellData[cellIndex].octBBox.getCenter();
            Size numDims;
            UInt8 cellBits = cellBBoxGetIntersectingObjectSubcellBits( centerPath, octBBox, numDims );
            for( Size bit = 0; bit < 8; ++bit ) {
              if( (UInt16(1<<bit) & cellBits) != 0 ) {
                UInt32 subCell = this.packedCellData[cellIndex].subCellIndices[bit];
                if( subCell )
                  tempTraverseData.pushToNext( subCell, Vec3() );
              }
            }
          }
        }
      }
    }
    tempTraverseData.swap();
    ++currDepth;
    currCellVolume /= 8;
  }

  // Now that we have a set containing all potential objects, filter on objects' actual bboxes and bSpheres
  Size target = nbInfinite;
  Size numObjects = result.size()-nbInfinite;
  for( Size i = 0; i < numObjects; ++i ) {
    UInt32 objectID = result.indices[i+nbInfinite];
    Boolean keep = this.objectData[objectID].intersectsBBox( min, max );
    if(keep)
      result.indices[target++] = objectID;
    else
      result.memberBits.clear( objectID );
  }
  result.indicesSize = target;
}

/// \internal
inline fillSubCellDeltaCenters(io Vec3 subCellDeltaCenters[8], Scalar radius) {
  subCellDeltaCenters[0] = Vec3( -radius, -radius, -radius );
  subCellDeltaCenters[1] = Vec3(  radius, -radius, -radius );
  subCellDeltaCenters[2] = Vec3( -radius,  radius, -radius );
  subCellDeltaCenters[3] = Vec3(  radius,  radius, -radius );
  subCellDeltaCenters[4] = Vec3( -radius, -radius,  radius );
  subCellDeltaCenters[5] = Vec3(  radius, -radius,  radius );
  subCellDeltaCenters[6] = Vec3( -radius,  radius,  radius );
  subCellDeltaCenters[7] = Vec3(  radius,  radius,  radius );
}

function OctreeStruct.addCellObjects?(
  OctCellData cell,
  BitVector objectMask,
  io IndexSet result,
  Boolean includeSubCells
  ) {
  Boolean noMask = objectMask.size() == 0;

  //Add cell-exclusive objects
  OctreeArrayIterator it = this.packedMemberLists.getIterator( cell.arrays[OctreeCellArray_cellObjects] );
  UInt32 objectIndex;
  while( this.packedMemberLists.getNext( it, objectIndex ) ) {
    if( noMask || objectMask.get(objectIndex) )
      result.add( objectIndex );
  }

  //Important: include non-updated objects
  it = this.packedMemberLists.getIterator( cell.arrays[OctreeCellArray_toClassifyObjects] );
  while( this.packedMemberLists.getNext( it, objectIndex ) ) {
    if( noMask || objectMask.get(objectIndex) )
      result.add( objectIndex );
  }

  if( includeSubCells ) {
    //Add subcell objects
    it = this.packedMemberLists.getIterator( cell.arrays[OctreeCellArray_subCellObjects] );
    while( this.packedMemberLists.getNext( it, objectIndex ) ) {
      if( noMask || objectMask.get(objectIndex) )
      result.add( objectIndex );
    }
    if( !this.keepSubCellObjectList && cell.isSubdivided() ) {
      //We need to traverse all children (slower!)
      for( Size subIndex = 0; subIndex < 8; ++subIndex ) {
        UInt32 subCell = cell.subCellIndices[subIndex];
        if( subCell )
          this.addCellObjects( this.packedCellData[subCell], objectMask, result, true);
      }
    }
  }
}

function OctreeStruct.processQueriedIntersectedCell?(
  UInt8 intersectionType, OctCellData cell, Vec3 currCellCenter,
  UInt8 currDepth, UInt8 maxSearchDepth,
  OctCellBBox octBBox,
  Vec3 subCellDeltaCenters[8],
  io OctreeQueryTraverseData tempTraverseData,
  BitVector objectMask, io IndexSet result
  ) {
  Boolean noMask = objectMask.size() == 0;
  Boolean allCellObjects = !cell.isSubdivided() || intersectionType == IntersectionIncludesOther || currDepth == maxSearchDepth;
  this.addCellObjects( cell, objectMask, result, allCellObjects );
 
  if( !allCellObjects ) {
    Boolean keep;
    if( this.keepSubCellObjectList ) {
      //First, ensure that there are potential objects that can be discarded by going deeper
      UInt32 objectIndex;
      OctreeArrayIterator it = this.packedMemberLists.getIterator( cell.arrays[OctreeCellArray_subCellObjects] );
      while( this.packedMemberLists.getNext( it, objectIndex ) ) {
        if( (noMask || objectMask.get(objectIndex) ) && !result.has(objectIndex) ) {
          keep = true;
          break;
        }
      }
    } else
      keep = true;

    if(keep) {
      //Partial: push only intersected subcells
      OctCellPath centerPath = cell.octBBox.getCenter();
      Size numDims;
      UInt8 cellBits = cellBBoxGetIntersectingObjectSubcellBits( centerPath, octBBox, numDims );
      for( Size bit = 0; bit < 8; ++bit ) {
        if( (UInt16(1<<bit) & cellBits) != 0 ) {
          UInt32 subCell = cell.subCellIndices[bit];
          if( subCell )
            tempTraverseData.pushToNext( subCell, currCellCenter + subCellDeltaCenters[bit] );
        }
      }
    }
  }
}

operator ParallelComputeBBoxSphereIntersection<<<index>>>(Size batchSize, Size offset, IndexSet indices, LocalBoundingVolume bSphere, OctObjectData objectData[], io UInt8 keepObjects[] ) {
  Size start = index*batchSize+offset;
  Size end = start + batchSize;
  if( end > indices.size() )
    end = indices.size();
  for( Size i = start; i < end; ++i ) {
    UInt32 objectID = indices.indices[i];
    if( objectData[objectID].intersectsBSphere( bSphere ) )
      keepObjects[i-offset] = 1;
  }
}

//NOTE: this is conservative, can return more objects than the 'exact' result
function OctreeStruct.localBSphereQuery?( LocalBoundingVolume bSphere, io OctreeQueryTraverseData tempTraverseData, io IndexSet result, BitVector objectMask ) {
  result.clear();
  tempTraverseData.reset();
  Boolean noMask = objectMask.size() == 0;

  //First add infinite results
  Size nbInfinite = 0;
  UInt32 infiniteObjectIndex;
  OctreeArrayIterator it = this.packedMemberLists.getIterator( this.getInfiniteBVolList() );
  while( this.packedMemberLists.getNext( it, infiniteObjectIndex ) ) {
    if(noMask || objectMask.get(infiniteObjectIndex)) {
      ++nbInfinite;
      result.add( infiniteObjectIndex );
    }
  }

  Scalar bSphereSquaredRadius = bSphere.bSphereGetSquaredRadius();
  Vec3 bSphereCenter = bSphere.bSphereGetCenter();
  Scalar bSphereRadius = bSphere.bSphereGetRadius();

  UInt8 maxSearchDepth;
  OctCellBBox octBBox = this.getOctBBoxAndMaxSearchDepth( bSphereCenter-Vec3(bSphereRadius, bSphereRadius, bSphereRadius), bSphereCenter+Vec3(bSphereRadius, bSphereRadius, bSphereRadius), maxSearchDepth );
  Scalar cellRadius = (this.gridMax.x - this.gridMin.x)*0.5;
  Scalar halfRadius = cellRadius*0.5;

  Vec3 subCellDeltaCenters[8];
  fillSubCellDeltaCenters(subCellDeltaCenters, halfRadius);

  tempTraverseData.pushToNext( this.rootCellIndex, (this.gridMin + this.gridMax)*0.5 );
  tempTraverseData.swap();

  UInt8 currDepth = 0;

  while( tempTraverseData.size() != 0 && currDepth <= maxSearchDepth ) {
    Vec3 cellRadiusVec = Vec3(cellRadius, cellRadius, cellRadius);
    Size numCells = tempTraverseData.size();
    for( Size i = 0; i < numCells; ++i ) {
      Vec3 cellCenter;
      Size cellIndex;
      tempTraverseData.get( i, cellIndex, cellCenter );
      UInt8 intersectionType = bSphereGetBBoxIntersection( bSphereCenter, bSphereRadius, cellCenter-cellRadiusVec, cellCenter+cellRadiusVec );
      if( intersectionType == IntersectionNone )
        continue;
      else {
        this.processQueriedIntersectedCell( intersectionType, this.packedCellData[cellIndex], cellCenter, currDepth, maxSearchDepth, octBBox,
          subCellDeltaCenters, tempTraverseData, objectMask, result);
      }
    }
    for( Size i = 0; i < 8; ++i )
      subCellDeltaCenters[i] *= 0.5;
    cellRadius *= 0.5;
    tempTraverseData.swap();
    ++currDepth;
  }

  // Now that we have a set containing all potential objects, filter on objects' actual bboxes and bSpheres
  Size target = nbInfinite;
  Size numObjects = result.size()-nbInfinite;

  Size batchSize, numBatches;
  GetBatchSizeAndCountForParallel( numObjects, 1, 500, numBatches, batchSize );

  if( numBatches == 1 ) {
    for( Size i = 0; i < numObjects; ++i ) {
      UInt32 objectID = result.indices[i+nbInfinite];
      Boolean keep = this.objectData[objectID].intersectsBSphere( bSphere );
      if(keep)
        result.indices[target++] = objectID;
      else
        result.memberBits.clear( objectID );
    }
  } else {
    UInt8 keepObjects[];
    keepObjects.resize(numObjects);
    ParallelComputeBBoxSphereIntersection<<<numBatches>>>(batchSize, nbInfinite, result, bSphere, this.objectData, keepObjects );

    for( Size i = 0; i < numObjects; ++i ) {
      if(keepObjects[i])
        result.indices[target++] = result.indices[i+nbInfinite];
      else
        result.memberBits.clear( result.indices[i+nbInfinite] );
    }
  }
  result.indicesSize = target;
}

//NOTE: this is conservative, can return more objects than the 'exact' result
inline OctreeStruct.bSphereQuery?( Mat44 transform, LocalBoundingVolume localBSphere, io OctreeQueryTraverseData tempTraverseData, io IndexSet result, BitVector objectMask ) {
  Scalar bSphereSquaredRadius;
  Vec3 bSphereCenter;
  transformedBSphereGetBSphere( transform, localBSphere.pt1, localBSphere.sc1, bSphereCenter, bSphereSquaredRadius );
  Scalar bSphereRadius = sqrt(bSphereSquaredRadius);

  LocalBoundingVolume bSphere;
  bSphere.bSphereInit(bSphereCenter, bSphereRadius);
  this.localBSphereQuery( bSphere, tempTraverseData, result, objectMask );
}

/// \internal
struct ConeIntersectData {
  Vec3 origin;
  Vec3 unitDir;
  Scalar length;
  Scalar tanHalfAngle;
  Scalar invCosHalfAngle;
};

operator ParallelComputeBSphereConeIntersection<<<index>>>(Size batchSize, Size offset, IndexSet indices, ConeIntersectData coneIData, OctCellBBox octBBox, OctObjectData objectData[], io UInt8 keepObjects[] ) {
  Size start = index*batchSize+offset;
  Size end = start + batchSize;
  if( end > indices.size() )
    end = indices.size();

  for( Size i = start; i < end; ++i ) {
    Boolean keep = true;
    UInt32 objectID = indices.indices[i];
    UInt8 intersectionType = octBBox.getIntersectionType( objectData[objectID].octBBox );
    if( intersectionType == IntersectionNone )
      keep = false;
    else if( !bConeIntersectsBSphere( coneIData.origin, coneIData.unitDir, coneIData.length, coneIData.tanHalfAngle, coneIData.invCosHalfAngle, objectData[objectID].getCenter(), objectData[objectID].radius ) )
      keep = false;

    if(keep)
      keepObjects[i-offset] = 1;
  }
}

//NOTE: this is conservative, can return more objects than the 'exact' result
function OctreeStruct.bConeQuery?( Vec3 origin, Vec3 unitDir, Scalar length, Scalar tanHalfAngle, Scalar cosHalfAngle, io OctreeQueryTraverseData tempTraverseData, io IndexSet result, BitVector objectMask ) {
  result.clear();
  tempTraverseData.reset();
  Boolean noMask = objectMask.size() == 0;

  //First add infinite results
  Size nbInfinite = 0;
  UInt32 infiniteObjectIndex;
  OctreeArrayIterator it = this.packedMemberLists.getIterator( this.getInfiniteBVolList() );
  while( this.packedMemberLists.getNext( it, infiniteObjectIndex ) ) {
    if(noMask || objectMask.get(infiniteObjectIndex)) {
      ++nbInfinite;
      result.add( infiniteObjectIndex );
    }
  }

  Vec3 min, max;
  coneGetBBox( origin, unitDir, length, tanHalfAngle, min, max );

  UInt8 maxSearchDepth;
  OctCellBBox octBBox = this.getOctBBoxAndMaxSearchDepth( min, max, maxSearchDepth );
  maxSearchDepth += 3;//Because we are a Cone...

  Vec3 subCellDeltaCenters[8];
  Scalar radius = (this.gridMax.x - this.gridMin.x)*0.5;
  Scalar cellBSphereRadius = radius*1.733;//1.733 = sqrt(1 * 3)

  ConeIntersectData coneIData;
  coneIData.origin = origin;
  coneIData.unitDir = unitDir;
  coneIData.length = length;
  coneIData.tanHalfAngle = tanHalfAngle;
  coneIData.invCosHalfAngle = 1.0 / cosHalfAngle;

  Scalar halfRadius = radius*0.5;
  fillSubCellDeltaCenters(subCellDeltaCenters, halfRadius);

  tempTraverseData.pushToNext( this.rootCellIndex, (this.gridMin + this.gridMax)*0.5 );
  tempTraverseData.swap();

  UInt8 currDepth = 0;

  while( tempTraverseData.size() != 0 && currDepth <= maxSearchDepth ) {
    Size numCells = tempTraverseData.size();
    for( Size i = 0; i < numCells; ++i ) {
      Vec3 cellCenter;
      Size cellIndex;
      tempTraverseData.get( i, cellIndex, cellCenter );
      UInt8 intersectionType = bConeGetBSphereIntersection( coneIData.origin, coneIData.unitDir, coneIData.length, coneIData.tanHalfAngle, coneIData.invCosHalfAngle, cellCenter, cellBSphereRadius );
      if( intersectionType == IntersectionNone )
        continue;
      else {
        this.processQueriedIntersectedCell( intersectionType, this.packedCellData[cellIndex], cellCenter, currDepth, maxSearchDepth, octBBox,
          subCellDeltaCenters, tempTraverseData, objectMask, result);
      }
    }
    for( Size i = 0; i < 8; ++i )
      subCellDeltaCenters[i] *= 0.5;
    radius *= 0.5;
    cellBSphereRadius *= 0.5;
    tempTraverseData.swap();
    ++currDepth;
  }

  // Now that we have a set containing all potential objects, filter on objects' actual bCones and bSpheres
  Size target = nbInfinite;
  Size numObjects = result.size()-nbInfinite;

  Size batchSize, numBatches;
  GetBatchSizeAndCountForParallel( numObjects, 1, 50, numBatches, batchSize );

  if( numBatches == 1 ) {
    for( Size i = 0; i < numObjects; ++i ) {
      Boolean keep = true;
      UInt32 objectID = result.indices[i+nbInfinite];
      UInt8 intersectionType = octBBox.getIntersectionType( this.objectData[objectID].octBBox );
      if( intersectionType == IntersectionNone )
        keep = false;
      else if( !bConeIntersectsBSphere( origin, unitDir, length, tanHalfAngle, coneIData.invCosHalfAngle, this.objectData[objectID].getCenter(), this.objectData[objectID].radius ) )
        keep = false;

      if(keep)
        result.indices[target++] = objectID;
      else
        result.memberBits.clear( objectID );
    }
  } else {
    UInt8 keepObjects[];
    keepObjects.resize(numObjects);
    ParallelComputeBSphereConeIntersection<<<numBatches>>>(batchSize, nbInfinite, result, coneIData, octBBox, this.objectData, keepObjects );

    for( Size i = 0; i < numObjects; ++i ) {
      if(keepObjects[i])
        result.indices[target++] = result.indices[i+nbInfinite];
      else
        result.memberBits.clear( result.indices[i+nbInfinite] );
    }
  }
  result.indicesSize = target;
//report("Cone query: "+coneIData+" result: "+result.indices);
}

/// \internal
struct BoxIntersectData {
  LocalBoundingVolume noScalingLocalBVol;
  Mat44 noScalingInvTransform;
};

operator ParallelComputeBSphereBoxIntersection<<<index>>>( Size batchSize, Size offset, IndexSet indices, BoxIntersectData boxIData, OctCellBBox octBBox, OctObjectData objectData[], io UInt8 keepObjects[] ) {
  Size start = index*batchSize+offset;
  Size end = start + batchSize;
  if( end > indices.size() )
    end = indices.size();

  for( Size i = start; i < end; ++i ) {
    Boolean keep = true;
    UInt32 objectID = indices.indices[i];
    UInt8 intersectionType = octBBox.getIntersectionType( objectData[objectID].octBBox );
    if( intersectionType == IntersectionNone )
      keep = false;
    else if( boxIData.noScalingLocalBVol.bBoxGetBSphereIntersection( boxIData.noScalingInvTransform, objectData[objectID].getCenter(), objectData[objectID].radius ) == IntersectionNone )
      keep = false;

    if(keep)
      keepObjects[i-offset] = 1;
  }
}

//NOTE: this is conservative, can return more objects than the 'exact' result
function OctreeStruct.bBoxQuery?( Mat44 transform, LocalBoundingVolume localBBox, io OctreeQueryTraverseData tempTraverseData, io IndexSet result, BitVector objectMask ) {
  result.clear();
  tempTraverseData.reset();
  Boolean noMask = objectMask.size() == 0;

  Mat44 noScalingTransform;
  BoxIntersectData boxIData;
  transformedBBoxComputeUnscaled(transform, localBBox, noScalingTransform, boxIData.noScalingLocalBVol);
  boxIData.noScalingInvTransform = noScalingTransform.inverse();

  //First add infinite results
  Size nbInfinite = 0;
  UInt32 infiniteObjectIndex;
  OctreeArrayIterator it = this.packedMemberLists.getIterator( this.getInfiniteBVolList() );
  while( this.packedMemberLists.getNext( it, infiniteObjectIndex ) ) {
    if(noMask || objectMask.get(infiniteObjectIndex)) {
      ++nbInfinite;
      result.add( infiniteObjectIndex );
    }
  }
  Vec3 min, max;
  transformedBBoxGetBBox( noScalingTransform, boxIData.noScalingLocalBVol, min, max );

  UInt8 maxSearchDepth;
  OctCellBBox octBBox = this.getOctBBoxAndMaxSearchDepth( min, max, maxSearchDepth );
  maxSearchDepth += 2;//Because of orientation...

  Vec3 subCellDeltaCenters[8];
  Scalar radius = (this.gridMax.x - this.gridMin.x)*0.5;
  Scalar cellBSphereRadius = radius*1.733;//1.733 = sqrt(1 * 3)

  Scalar halfRadius = radius*0.5;
  fillSubCellDeltaCenters(subCellDeltaCenters, halfRadius);

  tempTraverseData.pushToNext( this.rootCellIndex, (this.gridMin + this.gridMax)*0.5 );
  tempTraverseData.swap();

  UInt8 currDepth = 0;
  
  while( tempTraverseData.size() != 0 && currDepth <= maxSearchDepth ) {
    Size numCells = tempTraverseData.size();
    for( Size i = 0; i < numCells; ++i ) {
      Vec3 cellCenter;
      Size cellIndex;
      tempTraverseData.get( i, cellIndex, cellCenter );
      UInt8 intersectionType = boxIData.noScalingLocalBVol.bBoxGetBSphereIntersection( boxIData.noScalingInvTransform, cellCenter, cellBSphereRadius );
      if( intersectionType == IntersectionNone )
        continue;
      else {
        this.processQueriedIntersectedCell( intersectionType, this.packedCellData[cellIndex], cellCenter, currDepth, maxSearchDepth, octBBox,
          subCellDeltaCenters, tempTraverseData, objectMask, result);
      }
    }
    for( Size i = 0; i < 8; ++i )
      subCellDeltaCenters[i] *= 0.5;
    radius *= 0.5;
    cellBSphereRadius *= 0.5;
    tempTraverseData.swap();
    ++currDepth;
  }

  // Now that we have a set containing all potential objects, filter on objects' actual bboxes and bSpheres
  Size target = nbInfinite;
  Size numObjects = result.size()-nbInfinite;

  Size batchSize, numBatches;
  GetBatchSizeAndCountForParallel( numObjects, 1, 75, numBatches, batchSize );

  if( numBatches == 1 ) {
    for( Size i = 0; i < numObjects; ++i ) {
      Boolean keep = true;
      UInt32 objectID = result.indices[i+nbInfinite];
      UInt8 intersectionType = octBBox.getIntersectionType( this.objectData[objectID].octBBox );
      if( intersectionType == IntersectionNone )
        keep = false;
      else if( boxIData.noScalingLocalBVol.bBoxGetBSphereIntersection( boxIData.noScalingInvTransform, this.objectData[objectID].getCenter(), this.objectData[objectID].radius ) == IntersectionNone )
        keep = false;

      if(keep)
        result.indices[target++] = objectID;
      else
        result.memberBits.clear( objectID );
    }
  } else {
    UInt8 keepObjects[];
    keepObjects.resize(numObjects);
    ParallelComputeBSphereBoxIntersection<<<numBatches>>>(batchSize, nbInfinite, result, boxIData, octBBox, this.objectData, keepObjects );

    for( Size i = 0; i < numObjects; ++i ) {
      if(keepObjects[i])
        result.indices[target++] = result.indices[i+nbInfinite];
      else
        result.memberBits.clear( result.indices[i+nbInfinite] );
    }
  }
  result.indicesSize = target;
//report("box query: "+boxIData+" result: "+result.indices);
}


/// \internal
struct PyramidIntersectData {
  Vec3 origin;
  Vec3 unitDir;
  Scalar nearValue;
  Scalar farValue;
  Vec3 leftPlaneNormal;
  Vec3 rightPlaneNormal;
  Vec3 upPlaneNormal;
  Vec3 downPlaneNormal;
};

operator ParallelComputeBSpherePyramidIntersection<<<index>>>( Size batchSize, Size offset, IndexSet indices, PyramidIntersectData pyrIData, OctCellBBox octBBox, OctObjectData objectData[], io UInt8 keepObjects[] ) {
  Size start = index*batchSize+offset;
  Size end = start + batchSize;
  if( end > indices.size() )
    end = indices.size();

  for( Size i = start; i < end; ++i ) {
    Boolean keep = true;
    UInt32 objectID = indices.indices[i];
    UInt8 intersectionType = octBBox.getIntersectionType( objectData[objectID].octBBox );
    if( intersectionType == IntersectionNone )
      keep = false;
    else if( !bPyramidIntersectsBSphere( pyrIData.origin, pyrIData.unitDir, pyrIData.nearValue, pyrIData.farValue, pyrIData.leftPlaneNormal, pyrIData.rightPlaneNormal, pyrIData.upPlaneNormal, pyrIData.downPlaneNormal, objectData[objectID].getCenter(), objectData[objectID].radius ) )
      keep = false;

    if(keep)
      keepObjects[i-offset] = 1;
  }
}

//NOTE: this is conservative, can return more objects than the 'exact' result
function OctreeStruct.bPyramidQuery?( Vec3 origin, Vec3 unitDir, Scalar near, Scalar far, Vec3 nearRightVec, Vec3 nearUpVec, io OctreeQueryTraverseData tempTraverseData, io IndexSet result, BitVector objectMask ) {
  result.clear();
  tempTraverseData.reset();
  Boolean noMask = objectMask.size() == 0;

  //First add infinite results
  Size nbInfinite = 0;
  UInt32 infiniteObjectIndex;
  OctreeArrayIterator it = this.packedMemberLists.getIterator( this.getInfiniteBVolList() );
  while( this.packedMemberLists.getNext( it, infiniteObjectIndex ) ) {
    if(noMask || objectMask.get(infiniteObjectIndex)) {
      ++nbInfinite;
      result.add( infiniteObjectIndex );
    }
  }

  PyramidIntersectData pyrIData;
  pyrIData.origin = origin;
  pyrIData.unitDir = unitDir;
  pyrIData.nearValue = near;
  pyrIData.farValue = far;

  bPyramidComputePlanes( origin, unitDir, near, far, nearRightVec, nearUpVec, 
    pyrIData.leftPlaneNormal, pyrIData.rightPlaneNormal, pyrIData.upPlaneNormal, pyrIData.downPlaneNormal );
  //report("bPyramidComputePlanes leftPlaneNormal "+leftPlaneNormal+" rightPlaneNormal "+rightPlaneNormal+" upPlaneNormal "+upPlaneNormal+" downPlaneNormal "+downPlaneNormal);
  Vec3 min, max;
  pyramidGetBBox( origin, unitDir, near, far, nearRightVec, nearUpVec, min, max );

  UInt8 maxSearchDepth;
  OctCellBBox octBBox = this.getOctBBoxAndMaxSearchDepth( min, max, maxSearchDepth );
  maxSearchDepth += 3;//Because we are a Pyramid...

  Vec3 subCellDeltaCenters[8];
  Scalar radius = (this.gridMax.x - this.gridMin.x)*0.5;
  Scalar cellBSphereRadius = radius*1.733;//1.733 = sqrt(1 * 3)

  Scalar halfRadius = radius*0.5;
  fillSubCellDeltaCenters(subCellDeltaCenters, halfRadius);

  tempTraverseData.pushToNext( this.rootCellIndex, (this.gridMin + this.gridMax)*0.5 );
  tempTraverseData.swap();

  UInt8 currDepth = 0;
  while( tempTraverseData.size() != 0 && currDepth <= maxSearchDepth ) {
    Size numCells = tempTraverseData.size();
    for( Size i = 0; i < numCells; ++i ) {
      Vec3 cellCenter;
      Size cellIndex;
      tempTraverseData.get( i, cellIndex, cellCenter );
      UInt8 intersectionType = bPyramidGetBSphereIntersection( pyrIData.origin, pyrIData.unitDir, pyrIData.nearValue, pyrIData.farValue, pyrIData.leftPlaneNormal, pyrIData.rightPlaneNormal, pyrIData.upPlaneNormal, pyrIData.downPlaneNormal, cellCenter, cellBSphereRadius );
      if( intersectionType == IntersectionNone )
        continue;
      else {
        this.processQueriedIntersectedCell( intersectionType, this.packedCellData[cellIndex], cellCenter, currDepth, maxSearchDepth, octBBox,
          subCellDeltaCenters, tempTraverseData, objectMask, result);
      }
    }
    for( Size i = 0; i < 8; ++i )
      subCellDeltaCenters[i] *= 0.5;
    radius *= 0.5;
    cellBSphereRadius *= 0.5;
    tempTraverseData.swap();
    ++currDepth;
  }
  // Now that we have a set containing all potential objects, filter on objects' actual bPyramids and bSpheres
  Size target = nbInfinite;
  Size numObjects = result.size()-nbInfinite;

  Size batchSize, numBatches;
  GetBatchSizeAndCountForParallel( numObjects, 1, 50, numBatches, batchSize );

  if( numBatches == 1 ) {
    for( Size i = 0; i < numObjects; ++i ) {
      Boolean keep = true;
      UInt32 objectID = result.indices[i+nbInfinite];
      UInt8 intersectionType = octBBox.getIntersectionType( this.objectData[objectID].octBBox );
      if( intersectionType == IntersectionNone )
        keep = false;
      else if( !bPyramidIntersectsBSphere( pyrIData.origin, pyrIData.unitDir, pyrIData.nearValue, pyrIData.farValue, pyrIData.leftPlaneNormal, pyrIData.rightPlaneNormal, pyrIData.upPlaneNormal, pyrIData.downPlaneNormal, this.objectData[objectID].getCenter(), this.objectData[objectID].radius ) ) {
        keep = false;
      }

      if(keep)
        result.indices[target++] = objectID;
      else
        result.memberBits.clear( objectID );
    }
  } else {
    UInt8 keepObjects[];
    keepObjects.resize(numObjects);
    ParallelComputeBSpherePyramidIntersection<<<numBatches>>>(batchSize, nbInfinite, result, pyrIData, octBBox, this.objectData, keepObjects );

    for( Size i = 0; i < numObjects; ++i ) {
      if(keepObjects[i])
        result.indices[target++] = result.indices[i+nbInfinite];
      else
        result.memberBits.clear( result.indices[i+nbInfinite] );
    }
  }
  result.indicesSize = target;
//report("pyrCull: "+pyrIData+" result="+result.indices);
}

/// \internal
inline raycastTestObjectFromOutside( Size objectIndex, OctObjectData objectData, io RayQueryData rayData ) {
  Scalar dirFactor;
  if( intersectBBoxFromOutside( objectData.min, objectData.max, rayData, dirFactor ) && dirFactor >= rayData.startFactor )
    rayData.bestResult.compareAndUpdate( objectIndex, rayData.distFactor );
}

/// \internal
inline raycastTestObject( Size objectIndex, OctObjectData objectData, Vec3 currPos, io RayQueryData rayData ) {
  //First, test if inside
  if( BBoxContains( objectData.min, objectData.max, currPos ) )
    rayData.bestResult.compareAndUpdate( objectIndex, rayData.distFactor );
  else
    raycastTestObjectFromOutside( objectIndex, objectData, rayData );
}

function OctreeStruct.raycast( Ray ray, Boolean doubleSided, Scalar maxDistance, io SpatialQueryData tempData, io Ref<RaycastResult> result ) {
  tempData.cleanup(false);
  RayQueryData rayData(ray, doubleSided, maxDistance, result);

  Vec3 currPos = rayData.start;
  if( !_insideBBox( this.gridMin, this.gridMax, rayData.start ) ) {
    if( !intersectBBoxFromOutside( this.gridMin, this.gridMax, rayData, rayData.startFactor ) )
      return;
    currPos += rayData.startFactor*rayData.unitDir;
  }

  OctCellPath currGridPath;
  this.getOctCoord( currPos, currGridPath);
  Size cellIndexStack[14];//Oct_MAX_DEPTH

  cellIndexStack[0] = this.rootCellIndex;
  Size currStackDepth = 0;
  Size prevStackDepth = 0;

  Boolean firstLoop = true;
  while(true) {

    //Get down to lowest leaf
    Size nextDepthBit = 1<<(15-currStackDepth);
    OctCellBBox currCellBBox;

    while(true) {
      Size cellIndex = cellIndexStack[currStackDepth];
      if( !this.packedCellData[cellIndex].isSubdivided() ) {
        currCellBBox = this.packedCellData[cellIndex].octBBox;
        break;
      }
      UInt8 subCellPath = (currGridPath.xyz[0]&nextDepthBit?1u8:0u8) | ((currGridPath.xyz[1]&nextDepthBit?1u8:0u8)<<1) | ((currGridPath.xyz[2]&nextDepthBit?1u8:0u8)<<2);
      Size subCell = this.packedCellData[cellIndex].subCellIndices[subCellPath];
      cellIndexStack[++currStackDepth] = subCell;

      if( subCell == 0 ) {
        //Sparse subcell: compute bbox
        OctCellBBox parentCellBbox = this.packedCellData[cellIndexStack[currStackDepth-1]].octBBox;
        currCellBBox = ComputeSubCellBBox( parentCellBbox, parentCellBbox.getCenter(), subCellPath );
        break;
      }
      nextDepthBit >>= 1;
    }

    //Test objects from new cells, bottom to up (to maximize chances to hit sooner)
    for( Size i = currStackDepth+1; i-- > prevStackDepth; ) {
      Size cellIndex = cellIndexStack[i];
      if( cellIndex ) {//Don't test virtual cells

        Size numListTypes = this.packedCellData[cellIndex].isSubdivided() ? 2 : 3;
        for( Size listType = 0; listType < numListTypes; ++listType ) {
          UInt32 objectIndex;
          OctreeArrayIterator it = this.packedMemberLists.getIterator( this.packedCellData[cellIndex].arrays[listType] );
          while( this.packedMemberLists.getNext( it, objectIndex ) ) {
            if( tempData.visitedItems.add(objectIndex) ) {
              if( firstLoop )
                raycastTestObject( objectIndex, this.objectData[objectIndex], currPos, rayData );
              else
                raycastTestObjectFromOutside( objectIndex, this.objectData[objectIndex], rayData );
            }
          }
        }
      }
    }

    //Intersect outside of current cell
    Vec3 cellMin, cellMax;
    this.getBBox( currCellBBox, cellMin, cellMax );
    Scalar cellDistFactor;
    UInt8 cellIntersSide;
    intersectBBoxFromInside( cellMin, cellMax, rayData, cellDistFactor, cellIntersSide );

    if( cellDistFactor >= rayData.distFactor )
      return;//Done!

    //Goto next cell
    Boolean hitMin = rayData.dirSign3[cellIntersSide] == -1;
    currPos = rayData.start + cellDistFactor*rayData.unitDir;
    this.getOctCoord(currPos, currGridPath);

    //Ensure that the OctCoord is inside the next cell (rounding errors from Scalar to UInt16 to Scalar)
    for( UInt8 dim = 0; dim < 3; ++dim ) {
      if( dim == cellIntersSide ) {
        if( hitMin ) {
          UInt16 cellPos = currCellBBox.min.xyz[dim];
          if(cellPos == 0)
            return;//Done!
          currGridPath.xyz[dim] = cellPos-1;
        }
        else {
          UInt16 cellPos = currCellBBox.max.xyz[dim];
          if(cellPos == 65535)
            return;//Done!
          currGridPath.xyz[dim] = cellPos+1;
        }
      } else {
        if( currGridPath.xyz[dim] <= currCellBBox.min.xyz[dim] )
          currGridPath.xyz[dim] = currCellBBox.min.xyz[dim]+1;//Cells have at least a width of 2
        else if( currGridPath.xyz[dim] >= currCellBBox.max.xyz[dim] )
          currGridPath.xyz[dim] = currCellBBox.max.xyz[dim]-1;
      }
    }

    //Go up in hierarchy until we find the right level on that side
    UInt16 currHitOctPos = currGridPath.xyz[cellIntersSide];
    if( hitMin ) {
      while(true) {
        if( currStackDepth == 0 )
          return;//Done!
        --currStackDepth;
        Size parentCell = cellIndexStack[currStackDepth];
        UInt16 parentCellOctPos = this.packedCellData[parentCell].octBBox.min.xyz[cellIntersSide];
        if( parentCellOctPos < currHitOctPos )
          break;
      }
    } else {
      while(true) {
        if( currStackDepth == 0 )
          return;//Done!
        --currStackDepth;
        Size parentCell = cellIndexStack[currStackDepth];
        UInt16 parentCellOctPos = this.packedCellData[parentCell].octBBox.max.xyz[cellIntersSide];
        if( parentCellOctPos > currHitOctPos )
          break;
      }
    }
    prevStackDepth = currStackDepth+1;//Common ancestor has already been tested
    firstLoop = false;
  }
}

/// \internal
inline closestTestObject( Size objectIndex, io SpatialQueryData tempData, OctObjectData objectData, io ClosestQueryData closestData ) {
  Scalar bboxSqDist = getBBoxSquaredDistance( objectData.min, objectData.max, closestData );
  if( bboxSqDist < closestData.maxScaledSquaredDist ) {
    if( bboxSqDist < 1.0e-10 ) //squared 1e-5 eps
      closestData.bestResult.compareAndUpdate( objectIndex, closestData.maxScaledSquaredDist );
    else {
      QueryHeapItem heapItem;
      heapItem.objIndex = objectIndex;
      heapItem.distFactor = bboxSqDist;
      tempData.heap.insert(heapItem);
    }
  }
}

/// \internal
inline testCellObjectsForClosest( OctreeStruct octree, Size cellIndex, io SpatialQueryData tempData, io ClosestQueryData closestData ) {
  Size numListTypes = octree.packedCellData[cellIndex].isSubdivided() ? 2 : 3;
  for( Size listType = 0; listType < numListTypes; ++listType ) {
    UInt32 objectIndex;
    OctreeArrayIterator it = octree.packedMemberLists.getIterator( octree.packedCellData[cellIndex].arrays[listType] );
    while( octree.packedMemberLists.getNext( it, objectIndex ) ) {
      if( tempData.visitedItems.add(objectIndex) )
        closestTestObject( objectIndex, tempData, octree.objectData[objectIndex], closestData );
    }
  }
}

function OctreeStruct.getClosest( Vec3 position, Vec3 scaling, Scalar maxUnscaledDistance, io SpatialQueryData tempData, io Ref<ClosestResult> result ) {
  tempData.cleanup(false);

  //Before going recursive on octree's bboxes, first get closest distance bottom to up
  //of the closest stack to have a good initial cutoff, and minimize the amount of 
  //elements pushed on the heap.

  ClosestQueryData closestData;
  closestData.position = position;
  closestData.scaling = scaling;
  closestData.hasScaling = abs(scaling.x-1.0)>1.0e-5 || abs(scaling.y-1.0)>1.0e-5 || abs(scaling.z-1.0)>1.0e-5;
  closestData.maxScaledSquaredDist = maxUnscaledDistance*maxUnscaledDistance;
  closestData.bestResult = result;
  closestData.bestResult.reset( position, scaling, closestData.hasScaling );

  //Fill initial stack
  Vec3 rootBBoxClosestPos = bBoxGetClosestPoint( this.gridMin, this.gridMax, position );
  OctCellPath initialGridPath;
  this.getOctCoord( rootBBoxClosestPos, initialGridPath);

  Scalar initialSqDist = getScaledSquaredDistance( rootBBoxClosestPos, closestData );

  //Get down to lowest leaf
  Size initialStackDepth = 0;
  Size nextDepthBit = 1<<15;

  Size initialClosestCellStack[15];//Oct_MAX_DEPTH+1
  initialClosestCellStack[0] = this.rootCellIndex;

  while(true) {
    Size cellIndex = initialClosestCellStack[initialStackDepth];
    if( !this.packedCellData[cellIndex].isSubdivided() )
      break;

    UInt8 subCellPath = (initialGridPath.xyz[0]&nextDepthBit?1u8:0u8) | ((initialGridPath.xyz[1]&nextDepthBit?1u8:0u8)<<1) | ((initialGridPath.xyz[2]&nextDepthBit?1u8:0u8)<<2);
    Size subCell = this.packedCellData[cellIndex].subCellIndices[subCellPath];
    if( !subCell )
      break;

    initialClosestCellStack[++initialStackDepth] = subCell;
    nextDepthBit >>= 1;
  }

  //Initial stack path: fill the initial heap with these cells.
  //They all have the same distance, but higher depth should go first.
  //So: reverse the order of initialClosestCellStack
  tempData.heap.reset();
  if( tempData.heap.heapItems.size() < 14 )
    tempData.heap.heapItems.resize(14);

  Size depth = initialStackDepth;
  for( Size i = 0; i < initialStackDepth+1; ++i ) {
    QueryHeapItem heapItem;
    heapItem.cellIndex = initialClosestCellStack[depth];
    heapItem.cellDepth = depth;
    heapItem.distFactor = initialSqDist;
    tempData.heap.heapItems[i] = heapItem;
    --depth;
  }
  tempData.heap.heapItemsEnd = initialStackDepth+1;

  while( true ) {
    QueryHeapItem heapItem;

    if( !tempData.heap.popMin(heapItem) || heapItem.distFactor > closestData.maxScaledSquaredDist )
      break;

    if( heapItem.cellIndex == 0 ) //object
      closestData.bestResult.compareAndUpdate( heapItem.objIndex, closestData.maxScaledSquaredDist );
    else {
      testCellObjectsForClosest( this, heapItem.cellIndex, tempData, closestData );

      //Push subcells
      if( this.packedCellData[heapItem.cellIndex].isSubdivided() ) {
        Size initialSubCellForNextDepth = initialClosestCellStack[heapItem.cellDepth+1];

        Vec3 cellMin, cellMax;
        this.getBBox( this.packedCellData[heapItem.cellIndex].octBBox, cellMin, cellMax );
        Vec3 cellCenter = (cellMin + cellMax)*0.5;

        for( UInt8 j = 0; j < 8; ++j ) {
          Size subCell = this.packedCellData[heapItem.cellIndex].subCellIndices[j];
          if( subCell != 0 && initialSubCellForNextDepth != subCell ) {
            Vec3 subMin, subMax;
            ComputeSubCellBBox( cellMin, cellMax, cellCenter, j, subMin, subMax );
            Scalar subCellSqDist = getBBoxSquaredDistance( subMin, subMax, closestData );
            if( subCellSqDist < closestData.maxScaledSquaredDist ) {
              QueryHeapItem subHeapItem;
              subHeapItem.cellIndex = subCell;
              subHeapItem.distFactor = subCellSqDist;
              subHeapItem.cellDepth = heapItem.cellDepth+1;
              tempData.heap.insert(subHeapItem);
            }
          }
        }
      }
    }
  }
}

operator ParallelComputeBBoxLineIntersection<<<index>>>(Size batchSize, Size offset, IndexSet indices, RayQueryData rayData, OctObjectData objectData[], io UInt8 keepObjects[] ) {
  Size start = index*batchSize+offset;
  Size end = start + batchSize;
  if( end > indices.size() )
    end = indices.size();
  for( Size i = start; i < end; ++i ) {
    UInt32 objectID = indices.indices[i];
    Scalar dummy;
    if( intersectBBox( objectData[objectID].min, objectData[objectID].max, rayData, dummy ) )
      keepObjects[i-offset] = 1;
  }
}

//intersectionLineTypeEnum: 0 == line, 1 == semi-line, 2 == segment
function OctreeStruct.lineQuery?( Vec3 start, Vec3 end, UInt8 intersectionLineTypeEnum, io OctreeQueryTraverseData tempTraverseData, io IndexSet result, BitVector objectMask ) {
  result.clear();
  tempTraverseData.reset();

  //First add infinite results
  Size nbInfinite = 0;
  UInt32 infiniteObjectIndex;
  OctreeArrayIterator it = this.packedMemberLists.getIterator( this.getInfiniteBVolList() );
  while( this.packedMemberLists.getNext( it, infiniteObjectIndex ) ) {
    ++nbInfinite;
    result.add( infiniteObjectIndex );
  }
  RayQueryData rayData(start, end, intersectionLineTypeEnum);

  tempTraverseData.pushToNext( this.rootCellIndex, (this.gridMin + this.gridMax)*0.5 );
  tempTraverseData.swap();

  Vec3 subCellDeltaCenters[8];
  Scalar radius = (this.gridMax.x - this.gridMin.x)*0.5;
  Scalar halfRadius = radius*0.5;
  fillSubCellDeltaCenters(subCellDeltaCenters, halfRadius);

  OctCellBBox octBBox = this.packedCellData[this.rootCellIndex].octBBox;
  if(intersectionLineTypeEnum == 2) {
    //At least do better for semi-line
    Box3 segmentBox;
    segmentBox.merge(start);
    segmentBox.merge(end);
    this.getOctBBox( segmentBox.min, segmentBox.max, true, octBBox );
  }

  UInt8 currDepth = 0;
  while( tempTraverseData.size() != 0 ) {
    Vec3 cellRadiusVec = Vec3(radius, radius, radius);
    Size numCells = tempTraverseData.size();
    for( Size i = 0; i < numCells; ++i ) {
      Vec3 cellCenter;
      Size cellIndex;
      tempTraverseData.get( i, cellIndex, cellCenter );

      Scalar dummy;
      if( !intersectBBox( cellCenter-cellRadiusVec, cellCenter+cellRadiusVec, rayData, dummy ) )
        continue;
      else {
        this.processQueriedIntersectedCell( IntersectionOverlap, this.packedCellData[cellIndex], cellCenter, currDepth, this.maxDepth, octBBox,
          subCellDeltaCenters, tempTraverseData, objectMask, result);
      }
    }
    for( Size i = 0; i < 8; ++i )
      subCellDeltaCenters[i] *= 0.5;
    radius *= 0.5;
    tempTraverseData.swap();
    ++currDepth;
  }

  // Now that we have a set containing all potential objects, filter on objects' actual bboxes and bSpheres
  Size target = nbInfinite;
  Size numObjects = result.size()-nbInfinite;
  Size batchSize, numBatches;
  GetBatchSizeAndCountForParallel( numObjects, 1, 500, numBatches, batchSize );

  if( numBatches == 1 ) {
    for( Size i = 0; i < numObjects; ++i ) {
      UInt32 objectID = result.indices[i+nbInfinite];

      Scalar dummy;
      if( intersectBBox( this.objectData[objectID].min, this.objectData[objectID].max, rayData, dummy ) )
        result.indices[target++] = objectID;
      else
        result.memberBits.clear( objectID );
    }
  } else {
    UInt8 keepObjects[];
    keepObjects.resize(numObjects);
    ParallelComputeBBoxLineIntersection<<<numBatches>>>(batchSize, nbInfinite, result, rayData, this.objectData, keepObjects );

    for( Size i = 0; i < numObjects; ++i ) {
      if(keepObjects[i])
        result.indices[target++] = result.indices[i+nbInfinite];
      else
        result.memberBits.clear( result.indices[i+nbInfinite] );
    }
  }
  result.indicesSize = target;
}
